"""
Gasnier-Guillevic pairing-friendly curves from the paper
An algebraic point of view on the generation of pairing-friendly curves
Jean Gasnier and Aurore Guillevic
https://hal.science/hal-04205681
"""
import sage

from sys import version_info
if version_info[0] < 3:
    from exceptions import ValueError
from sage.functions.log import log
from sage.functions.other import ceil
from sage.arith.misc import XGCD, xgcd
from sage.arith.functions import lcm
from sage.rings.integer import Integer
from sage.rings.rational_field import Q, QQ
from sage.misc.functional import cyclotomic_polynomial
from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
from sage.rings.finite_rings.finite_field_constructor import FiniteField
from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
from sage.schemes.elliptic_curves.ell_finite_field import EllipticCurve_finite_field
from sage.schemes.elliptic_curves.constructor import EllipticCurve

import tnfs.curve.pairing_friendly_curve
from tnfs.curve.pairing_friendly_curve import get_curve_parameter_b_j0, get_curve_generator_order_r_j0
from tnfs.curve.pairing_friendly_curve import get_curve_parameter_a_j1728, get_curve_generator_order_r_j1728

allowed_k = [16,18,20,22,28]
possible_k = [16,18,20,22,28]
# sometimes the choice corresponds to different sets of congruences
# k=16, D=1, choice in {0,1,2,3}
# k=16, D=35
# k=16, D=227
# k=18, D=3, choice in {0,1,2,3,4,5,6,7,8}
# k=20, D=1, choice in {0,1} for two distinct families
# k=22, D=7, choice in {0,1}
# k=22, D=3
# k=22, D=1
# k=28, D=1, choice in {0,1,2,3} for different options of congruences
# k=28, D=11
# k=46, D=7, choice in {0,1}
# k=46, D=15, choice in {2,3}

def polynomial_params(k, D=None, choice=None):
    """
    Gasnier-Guillevic curves
    https://hal.science/hal-04205681
    INPUT:
    - `k`: curve embedding degree, possible values are 16, 18, 20, 22, 28
    - `choice`: which one of the family for the given embedding degree,
             most of the curves there are at least two possible families.

    RETURN: px, rx, tx, cx, yx, betax, lambx, D
    """
    if not k in possible_k:
        raise ValueError("Error with GG k={} does not exist".format(k))
    if not k in allowed_k:
        raise ValueError("Error with GG k={} is not implemented".format(k))

    QQx = QQ['x']; (x,) = QQx._first_ngens(1)

    if k == 16:
        if D is None or D in [1, 4]:
            if choice is None or choice == 0: # KSS and FST papers
                px = (x**10 + 2*x**9 + 5*x**8 + 48*x**6 + 152*x**5 + 240*x**4 + 625*x**2 + 2398*x + 3125)/980
                rx = (x**8 + 48*x**4 + 625)/61250 # 625 = 5^4, 61250 = 2*5^4*7^2
                tx = (2*x**5 + 41*x + 35)/35
                cx = 125 * (x**2 + 2*x + 5)/2 # C such that P+1-T = C*R
                yx = (x**5 + 5*x**4 + 38*x + 120)/70 # Y such that T^2 - 4*P = -4*Y^2
                betax = (x**9-11*x**8-16*x**7-120*x**6-32*x**5-498*x**4-748*x**3-2740*x**2-3115*x-5651)/4018
                lambx = (x**4 + 24)/7 # sqrt(-1) mod R
                D=4
                m = 70
                u_mod_m = [25,45]
            elif choice == 1:
                px = (x**10 - 6*x**9 + 13*x**8 - 240*x**6 + 488*x**5 - 3120*x**4 + 28561*x**2 + 112806*x + 371293)/736372
                rx = (x**8 - 240*x**4 + 28561)/808904642
                tx = (-2*x**5 + 597*x + 1547)/1547
                cx = 2197 * (x**2 - 6*x + 13)/2 # it is always a multiple of 57122
                yx = -(3*x**5 - 13*x**4 - 122*x + 1560)/1547 # with negative sign so as to match the G2 order formula below
                lambx = (x**4 - 120)/119
                betax = (17*x**9 - 139*x**8 + 664*x**7 - 2288*x**6 + 4552*x**5 - 4210*x**4 - 62068*x**3 + 169364*x**2 - 321347*x + 2059717)/994602
                D = 1
                m = 3094
                u_mod_m = [13, 169, 715, 897, 2197, 2379, 2925, 3081]
            elif choice == 2:
                px = (x**10 - 6*x**9 + 25*x**8 + 672*x**6 - 12464*x**5 + 16800*x**4 + 390625*x**2 - 1844154*x + 9765625)/27772900
                rx = (x**8 + 672*x**4 + 390625)/216975781250
                tx = (-4*x**5 + 237*x + 13175)/13175
                cx = 15625 * (x**2 - 6*x + 25)/2 # it is always a multiple of 781250
                yx = -(3*x**5 - 25*x**4 + 3116*x - 8400)/13175
                lambx = (x**4 + 336)/527
                betax = (17*x**9 - 29*x**8 + 412*x**7 + 1100*x**6 + 21724*x**5 - 120638*x**4 - 169336*x**3 - 1422200*x**2 + 2407225*x - 33452809)/7743738
                D = 1
                m = 26350
                u_mod_m = [925, 2475, 8375, 11775, 14575, 17975, 23875, 25425]
            elif choice == 3:
                px = (x**10 - 10*x**9 + 169*x**8 + 57120*x**6 - 582672*x**5 + 9653280*x**4 + 815730721*x**2 - 8483805110*x + 137858491849)/38613796
                rx = (x**8 + 57120*x**4 + 815730721)/93190709028482
                tx = (-12*x**5 - 341525*x + 40391)/40391
                cx = 4826809*(x**2 - 10*x + 169)/2 # multiple of 1631461442
                yx = -(5*x**5 - 169*x**4 + 145668*x - 4826640)/40391 # with negative sign to match the g2 order computation
                lambx = (x**4 + 28560)/239
                betax = (x**9 + 2853*x**8 - 28292*x**7 + 966004*x**6 - 4724228*x**5 + 162957614*x**4 - 824441688*x**3 + 27588104856*x**2 - 138514914551*x + 2326952957777)/39016499050
                D = 1
                m = 80782
                u_mod_m = [24843, 55939]
        elif D == 35:
            D = 35
            #px = (x**18 - 2*x**17 + 36*x**16 + 769792*x**10 - 40228864*x**9 + 27712512*x**8 + 2821109907456*x**2 - 9841709023232*x + 101559956668416)/384906956636160
            #rx = (x**16 + 769792*x**8 + 2821109907456)/13149986010536411136
            #tx = (-x**9 - 108544*x + 9948672)/9948672
            #cx = (x**2 - 2*x + 36)*4782969/140
            #yx = (x**9 - 36*x**8 + 10057216*x - 13856256)/348203520
            #betax = (17*x**17 + 76*x**16 + 1004*x**15 + 6696*x**14 + 36144*x**13 + 241056*x**12 + 1301184*x**11 + 8678016*x**10 + 59929088*x**9 - 314375168*x**8 - 1741474816*x**7 - 9261656064*x**6 - 62693093376*x**5 - 333419618304*x**4 - 2256951361536*x**3 - 12003106258944*x**2 - 33291380588544*x - 3073295126364160)/15238146555904
            #lambx = (-x**8 - 661248)/552704
            # m = 2 * 9 * 5 * 7 * 17 * 127
            #m = 1360170
            #u_mod_m = [3816, 83826, 149346, 229356, 243846, 389376, 469386, 563886, 629406, 643896, 949446, 963936, 1029456, 1123956, 1203966, 1349496]
            # 0 mod 2, 0 mod 9, 1 mod 5, 1 mod 7, 1,2,4,8,9,13,15,16 mod 17, 6,121 mod 127.
            # m = 9 * 5 * 7 * 17 * 127
            # 0 mod 9, 1/2=3 mod 5, 1/2=4 mod 7, 1/2=9,1,2,4,9/2=13,13/2=15,15/2=16,8 mod 17, 3,121/2=124 mod 127.
            # 0 mod 9, 3 mod 5, 4 mod 7, 1,2,4,8,9,13,15,16 mod 17, 3,124 mod 127.
            px = (x**18 - x**17 + 9*x**16 + 3007*x**10 - 78572*x**9 + 27063*x**8 + 43046721*x**2 - 75086281*x + 387420489)/1468303515
            rx = (x**16 + 3007*x**8 + 43046721)/200652862709601
            tx = (-x**9 - 424*x + 19431)/19431
            cx = (x**2 - x + 9) * 4782969 / 35
            yx = (x**9 - 18*x**8 + 39286*x - 27063)/680085
            betax = (17*x**17 + 38*x**16 + 251*x**15 + 837*x**14 + 2259*x**13 + 7533*x**12 + 20331*x**11 + 67797*x**10 + 234098*x**9 - 614014*x**8 - 1700659*x**7 - 4522293*x**6 - 15305931*x**5 - 40700637*x**4 - 137753379*x**3 - 366305733*x**2 - 507986154*x - 2344738103)/116257832
            lambx = (-x**8 - 2583)/2159
            m = 680085
            u_mod_m = [1908, 41913, 74673, 114678, 121923, 194688, 234693, 281943, 314703, 321948, 474723, 481968, 514728, 561978, 601983, 674748]
        elif D == 227:
            D = 227
            px = (x**18 - x**17 + 57*x**16 + 18213439*x**10 - 179070860*x**9 + 1038166023*x**8 + 111429157112001*x**2 - 1519318935531769*x + 6351461955384057)/6497274289753131
            rx = (x**16 + 18213439*x**8 + 111429157112001)/55953767496148569686004129
            cx = (x**2 - x + 57) * 1954897493193 / 227
            tx = (-x**9 - 8752408*x + 40391511)/40391511
            yx = (-x**9 + 114*x**8 - 89535430*x + 1038166023)/9168872997
            betax = (113*x**17 + 2966*x**16 + 9803*x**15 + 344565*x**14 + 558771*x**13 + 19640205*x**12 + 31849947*x**11 + 1119491685*x**10 + 3873565586*x**9 + 44768846978*x**8 - 158366828371*x**7 + 2619815480187*x**6 - 9026909217147*x**5 + 149329482370659*x**4 - 514533825377379*x**3 + 8511780495127563*x**2 - 16736933292854490*x + 137297359054316665)/38893730398547864
            lambx = (x**8 + 8752408)/708623
            m = 9168872997
            u_mod_m = [547293936, 681251403, 843532341, 1277558157, 2872044066, 2981508006, 3602308287, 3711772227, 5306258136, 5740283952, 5902564890, 6036522357, 7525374270, 7687655208, 8065034082, 8227315020]

    elif k == 18:
        if choice is None or choice == 0: # KSS and FST papers
            px = (x**8 + 5*x**7 + 7*x**6 + 37*x**5 + 188*x**4 + 259*x**3 + 343*x**2 + 1763*x + 2401)/21
            rx = (x**6 + 37*x**3 + 343)/343 # 343 = 7^3
            cx = (x**2 + 5*x + 7)*49/3
            tx = (x**4 + 16*x + 7)/7
            yx = (5*x**4 + 14*x**3 + 94*x + 259)/21 # Y such that T^2 - 4*P = -3*Y^2
            betax = (x**7 + 3*x**6 + 4*x**5 + 44*x**4 + 118*x**3 + 71*x**2 + 483*x + 1118)/24
            lambx = x**3 + 18
            D=3
            m = 21
            u_mod_m = [14]
        elif choice == 1:
            px = (x**8 - x**7 + 7*x**6 + 37*x**5 - 46*x**4 + 259*x**3 + 343*x**2 - 508*x + 2401)/21
            rx = (x**6 + 37*x**3 + 343)/343
            cx = 49*(x**2 - x + 7)/3
            tx = (-3*x**4 - 55*x + 7)/7
            yx = -(x**4 - 14*x**3 + 23*x - 259)/21 # with negative sign so that it matches with below line 270
            betax = (4*x**7 - 15*x**6 + 67*x**5 - 34*x**4 - 107*x**3 + 1289*x**2 - 2121*x + 3488)/15
            lambx = x**3 + 18
            D = 3
            m = 21
            u_mod_m = [14]
        elif choice == 2:
            px = (x**8 + 9*x**7 + 21*x**6 + 171*x**5 + 1692*x**4 + 3591*x**3 + 9261*x**2 + 61317*x + 194481)/163863
            rx = (x**6 + 171*x**3 + 9261)/2676429
            tx = (x**4 - 144*x + 1071)/1071
            yx = (3*x**4 + 14*x**3 + 282*x + 1197)/1071
            cx = (x**2 + 9*x + 21)*49/3
            betax = (x**7 + 11*x**6 + 60*x**5 + 444*x**4 + 2070*x**3 + 5283*x**2 + 34209*x + 54918)/62424
            lambx = (x**3 + 60)/51
            D = 3
            m = 357
            u_mod_m = [189]
        elif choice == 3:
            px = (x**8 - 6*x**7 + 21*x**6 + 171*x**5 - 414*x**4 + 3591*x**3 + 9261*x**2 + 20169*x + 194481)/163863
            rx = (x**6 + 171*x**3 + 9261)/2676429
            tx = (4*x**4 + 495*x + 1071)/1071
            yx = (2*x**4 - 14*x**3 + 69*x - 1197)/1071
            cx = (x**2 - 6*x + 21)*49/3
            lambx = (x**3 + 60)/51
            betax = (3*x**7 - 29*x**6 + 192*x**5 - 327*x**4 + 144*x**3 + 13050*x**2 - 24759*x + 147771)/39015
            D = 3
            m = 357
            u_mod_m = [189]
        elif choice == 4:
            px = (x**8 - 3*x**7 + 21*x**6 + 171*x**5 - 1278*x**4 + 3591*x**3 + 9261*x**2 - 81486*x + 194481)/163863
            rx = (x**6 + 171*x**3 + 9261)/2676429
            tx = (-5*x**4 - 351*x + 1071)/1071
            yx = (x**4 - 14*x**3 + 213*x - 1197)/1071
            cx = (x**2 - 3*x + 21)*49/3
            lambx = (x**3 + 60)/51
            betax = (2*x**7 - 19*x**6 + 123*x**5 - 330*x**4 - 1737*x**3 + 15489*x**2 - 54999*x + 69444)/23409
            D = 3
            m = 357
            u_mod_m = [189]
        elif choice == 5:
            px = (x**8 + x**7 + 7*x**6 + 17*x**5 + 188*x**4 + 119*x**3 + 343*x**2 + 1255*x + 2401)/7581
            rx = (x**6 + 17*x**3 + 343)/123823 # 7**3*19**2
            cx = (x**2 + x + 7)*49/3
            tx = (3*x**4 + 16*x + 133)/133
            yx = (x**4 + 14*x**3 + 94*x + 119)/399
            betax = (5*x**7 + 3*x**6 + 68*x**5 + 92*x**4 + 926*x**3 + 407*x**2 + 4767*x + 230)/8664
            lambx = (x**3 - 1)/19
            D = 3
            m = 399 # 3*7*19
            # 0 mod 7
            # 1 mod 3
            # 1, 7, 11 mod 19
            u_mod_m = [7, 49, 343]
        elif choice == 6:
            px = (x**8 + 4*x**7 + 7*x**6 + 17*x**5 - 46*x**4 + 119*x**3 + 343*x**2 - 1763*x + 2401)/7581
            rx = (x**6 + 17*x**3 + 343)/123823
            tx = (-2*x**4 - 55*x + 133)/133
            yx = (4*x**4 + 14*x**3 - 23*x + 119)/399
            cx = (x**2 + 4*x + 7)*49/3
            lambx = (x**3 - 1)/19
            betax = (x**7 + 15*x**6 + 58*x**5 + 199*x**4 + 262*x**3 - 134*x**2 + 1491*x - 4058)/5415
            D = 3
            m = 399 # 3*7*19
            u_mod_m = [7, 49, 343]
        elif choice == 7:
            px = (x**8 - 2*x**7 + 13*x**6 + 89*x**5 - 382*x**4 + 1157*x**3 + 2197*x**2 - 12605*x + 28561)/11271
            rx = (x**6 + 89*x**3 + 2197)/634933
            tx = (-4*x**4 - 161*x + 221)/221
            yx = (2*x**4 - 26*x**3 + 191*x - 1157)/663
            cx = (x**2 - 2*x + 13)*169/3
            lambx = (x**3 + 36)/17
            betax = (5*x**7 - 33*x**6 + 176*x**5 - 283*x**4 - 1312*x**3 + 10178*x**2 - 28041*x + 31610)/6069
            D = 3
            m = 663
            u_mod_m = [247]
        else:
            px = (x**8 - 5*x**7 + 13*x**6 + 89*x**5 - 292*x**4 + 1157*x**3 + 2197*x**2 - 2009*x + 28561)/11271
            rx = (x**6 + 89*x**3 + 2197)/(13**3*17**2)
            cx = (x**2 - 5*x + 13)*169/3
            tx = (3*x**4 + 176*x + 221)/221
            yx = (5*x**4 - 26*x**3 + 146*x - 1157)/663
            betax = (7*x**7 - 57*x**6 + 292*x**5 - 404*x**4 - 614*x**3 + 11311*x**2 - 23361*x + 63022)/6936
            lambx = (x**3+36)/17
            D = 3
            m = 663 # 3*13*17
            # 9 mod 17, 0 mod 13, 1 mod 3
            # 26 mod 13*17
            u_mod_m = [247]
            # if u = 26 mod 663, rx <- rx/3, cx <- cx*3 but 3 | qx
    elif k == 20: # Gasnier curve
        # two possibilities
        if choice is None or choice == 0:
            # a, b = 1,-2
            px = (x**12 - 2*x**11 + 5*x**10 + 76*x**7 + 176*x**6 + 380*x**5 + 3125*x**2 + 12938*x + 15625)/33620
            rx = (x**8 + 4*x**7 + 11*x**6 + 24*x**5 + 41*x**4 + 120*x**3 + 275*x**2 + 500*x + 625)/25625
            cx = 125*(x**4 - 6*x**3 + 18*x**2 - 30*x + 25)/164
            assert cx == (125/164) * (x**2 - 2*x + 5) * (x**2 - 4*x + 5)
            tx = (2*x**6 + 117*x + 205)/205
            yx = (x**6 - 5*x**5 - 44*x - 190)/205
            betax = (7*x**11 - 23*x**10 + 88*x**9 - 160*x**8 + 440*x**7 - 268*x**6 + 1682*x**5 + 1868*x**4 - 340*x**3 + 9340*x**2 + 20175*x + 68633)/43706
            lambx = (x**5 + 38)/41
            D = 1
            # m = 410
            # u_mod_m = [69, 75, 79, 135, 175, 239, 299, 315, 325, 339]
            m = 2050 # 2*5**2*41
            #u_mod_m = [315, 1365, 1715, 1815, 1965]
            #cofactor_r = [41, 41, 1, 1, 41]
            u_mod_m = [1715, 1815]
            cofactor_r = [1, 1]
        else:
            # a, b = 1, 2
            px = (x**12 - 2*x**11 + 5*x**10 - 76*x**7 - 176*x**6 - 380*x**5 + 3125*x**2 + 12938*x + 15625)/33620
            rx = (x**8 - 4*x**7 + 11*x**6 - 24*x**5 + 41*x**4 - 120*x**3 + 275*x**2 - 500*x + 625)/25625
            cx = 125*(x**4 + 2*x**3 + 2*x**2 + 10*x + 25)/164
            assert cx == (125/164) * (x**2 - 2*x + 5) * (x**2 + 4*x + 5)
            tx = (-2*x**6 + 117*x + 205)/205
            yx = (x**6 - 5*x**5 + 44*x + 190)/205
            betax = (x**11 + 11*x**10 - 16*x**9 + 120*x**8 - 80*x**7 + 524*x**6 - 826*x**5 - 1524*x**4 - 5380*x**3 - 7620*x**2 - 23775*x - 12581)/30258
            lambx = (x**5 - 38)/41
            D = 1
            # m = 410
            #u_mod_m = [71, 85, 95, 111, 171, 235, 275, 331, 335, 341] mod 410 so that Q generate primes, but it is not enough: we require Q=1 mod 5.
            # cofactor_r = [1, 5125, 5125, 41, 1, 125, 5125, 41, 125, 41]
            m = 2050 # 2*5**2*41
            #u_mod_m = [915, 1315, 1465, 1565, 1915]
            #cofactor_r = [41,41,1,1,41]
            u_mod_m = [1465, 1565]
            cofactor_r = [1, 1]
    elif k == 22:
        if D is None or D == 7:
            if choice is None or choice in [0,1]:
                D = 7
                px = (x**24 - x**23 + 2*x**22 + 67*x**13 + 94*x**12 + 134*x**11 + 2048*x**2 + 5197*x + 4096)/7406
                rx = (x**20 - x**19 - x**18 + 3*x**17 - x**16 - 5*x**15 + 7*x**14 + 3*x**13 - 17*x**12 + 11*x**11 + 23*x**10 + 22*x**9 - 68*x**8 + 24*x**7 + 112*x**6 - 160*x**5 - 64*x**4 + 384*x**3 - 256*x**2 - 512*x + 1024)/23 # and sometimes / 23^2
                cx = (x**2 - x + 2) * (x**2 + x + 2) / (2 * 7 * 23)
                tx = (x**12 + 45*x + 46)/46
                yx = (x**12 - 4*x**11 - 47*x - 134)/322
                m = 161
                # D = 7 = 3 mod 4 -> Chi = x**2 + x + 2 has roots (-1+sqrt(-7))/2 and (-1 - sqrt(-7))/2
                betax = (11*x**23 - 20*x**22 + 53*x**21 - 58*x**20 + 106*x**19 - 116*x**18 + 212*x**17 - 232*x**16 + 424*x**15 - 464*x**14 + 848*x**13 - 191*x**12 + 1322*x**11 + 1051*x**10 - 172*x**9 + 2102*x**8 - 344*x**7 + 4204*x**6 - 688*x**5 + 8408*x**4 - 1376*x**3 + 16816*x**2 + 19776*x + 36142)/18515 # mod p
                lambx = (x**11 + 22)/23 # mod r
                if choice is None or choice == 0:
                    u_mod_m = [32, 151] # and 7 | cxa = (x^2 - 2*x + 8) -> 2*u = 1 mod 7, 2*u mod 23 = [3, 18]
                else:
                    u_mod_m = [4,18,25,39,81,95,116,123,144] # and 7 | cxa -> 2*u = 1 mod 7, 2*u mod 23 = [1, 8, 6, 13, 4, 2, 9, 16, 12]
                    rx = rx/23
                    cx = cx*23
                #px = (x**24 - 2*x**23 + 8*x**22 + 137216*x**13 + 385024*x**12 + 1097728*x**11 + 8589934592*x**2 + 43595595776*x + 68719476736)/124252061696
                #rx = (x**20 - 2*x**19 - 4*x**18 + 24*x**17 - 16*x**16 - 160*x**15 + 448*x**14 + 384*x**13 - 4352*x**12 + 5632*x**11 + 23552*x**10 + 45056*x**9 - 278528*x**8 + 196608*x**7 + 1835008*x**6 - 5242880*x**5 - 4194304*x**4 + 50331648*x**3 - 67108864*x**2 - 268435456*x + 1073741824)/24117248 # and sometimes 554696704
                #cx = (x**2 - 2*x + 8) * (x**2 + 2*x + 8)/5152
                #tx = (x**12 + 92160*x + 188416)/188416
                #yx = (x**12 - 8*x**11 - 96256*x - 548864)/1318912
                #m = 322
                # Diskrep([2, 7, 23], {2: [(1, 0)], 7: [(1, 1), (1, 6)], 23: [(1, 1), (1, 2), (1, 3), (1, 4), (1, 6), (1, 8), (1, 9), (1, 12), (1, 13), (1, 16), (1, 18)]})
                #u_mod_m = [6, 8, 36, 48, 50, 62, 64, 78, 104, 118, 146, 162, 174, 188, 190, 202, 216, 232, 246, 288, 300, 302]
                # if u_mod_m = [64, 302] (u=1 mod 7) then rx, px can take prime values.
                # if u_mod_m = [118,202] (u=6 mod 7) then rx can take prime values but 7 | px and 7 | cb = (x**2 + 2*x + 8)
                # if u_mod_m = [8,36,50,78,162,190,232,246,288] (u=1 mod 7) then rx/23 and px can take prime values
                # if u_mod_m = [6,48,62,104,146,174,188,216,300] (u=6 mod 7) then rx/23 can take prime values but 7 | px and and 7 | cxb
                #if choice is None or choice==0:
                #    u_mod_m = [64, 302] # and 7 | cxa = (x**2 - 2*x + 8)
                #else:
                #    u_mod_m = [8,36,50,78,162,190,232,246,288] # and 7 | cxa -> u = 0 mod 2, u = 1 mod 7, u mod 23 = [8, 13, 4, 9, 1, 6, 2, 16, 12]
                #    rx = rx/23
                #    cx = cx*23
            else: #elif choice in [2,3]:
                D = 7
                px = (x**24 - 7*x**23 + 14*x**22 - 7**6*23*x**13 + 7**6*94*x**12 - 7**7*46*x**11 + 14**11*x**2 + 7**12*967*x + 14**12)/(2*7**12*67**2)
                rx = (x**20 - 7*x**19 + 35*x**18 - 147*x**17 + 539*x**16 - 1715*x**15 + 4459*x**14 - 7203*x**13 - 12005*x**12 + 184877*x**11 - 1126069*x**10 + 2588278*x**9 - 2352980*x**8 - 19765032*x**7 + 171296944*x**6 - 922368160*x**5 + 4058419904*x**4 - 15495785088*x**3 + 51652616960*x**2 - 144627327488*x + 289254654976)/(7**10*67)
                cx = (x**4 - 21*x**2 + 196)/6566
                tx = (-x**12 + 45*7**6*x + 134*7**6)/(2*7**6*67)
                yx = (-x**12 + 4*x**11 + 47*7**5*x - 46*7**6)/(2*7**6*67)
                betax = (x**23 - 16*x**22 + 91*x**21 - 350*x**20 + 1274*x**19 - 4900*x**18 + 17836*x**17 - 68600*x**16 + 249704*x**15 - 960400*x**14 + 3495856*x**13 - 16151527*x**12 + 44941918*x**11 - 87648505*x**10 + 418359844*x**9 - 1227079070*x**8 + 5857037816*x**7 - 17179106980*x**6 + 81998529424*x**5 - 240507497720*x**4 + 1147979411936*x**3 - 3367104968080*x**2 + 20121276936768*x - 39068021788194)/44381098746635# root of x^2+x+2 mod px
                lambx = (x**11 - 114*7**5)/(7**5*67)# root of x^2+x+2 mod rx
                m = 5159
                u_mod_m = [161, 1008, 1316, 1393, 2009, 2856, 2933, 3087, 3395, 3626, 4011]
                if choice == 2:
                    u_mod_m = [2933, 3626]
                else:
                    u_mod_m = [161, 1008, 1316, 1393, 2009, 2856, 3087, 3395, 4011]
                    rx = rx/67
                    cx = cx*67
        elif D == 3:
            D = 3
            px = (x**24 - 6*x**23 + 21*x**22 - 37431234*x**13 + 223805916*x**12 - 786055914*x**11 + 350277500542221*x**2 - 2087000802936846*x + 7355827511386641)/267191528688
            rx = (x**20 - 6*x**19 + 15*x**18 + 36*x**17 - 531*x**16 + 2430*x**15 - 3429*x**14 - 30456*x**13 + 254745*x**12 - 888894*x**11 - 16281*x**10 - 18666774*x**9 + 112342545*x**8 - 282053016*x**7 - 666875349*x**6 + 9924365430*x**5 - 45541810251*x**4 + 64839187476*x**3 + 567342890415*x**2 - 4765680279486*x + 16679880978201)/3956283
            cx = (x**4 + 6*x**2 + 441)/67536
            tx = (-x**12 + 18764460*x + 341901)/341901
            yx = (x**12 - 7*x**11 - 18650493*x + 131009319)/683802
            betax = (31*x**23 - 43*x**22 + 444*x**21 + 2100*x**20 + 9324*x**19 + 44100*x**18 + 195804*x**17 + 926100*x**16 + 4111884*x**15 + 19448100*x**14 + 86349564*x**13 - 751958154*x**12 + 3433824738*x**11 - 8365610340*x**10 - 39557170044*x**9 - 175677817140*x**8 - 830700570924*x**7 - 3689234159940*x**6 - 17444711989404*x**5 - 77473917358740*x**4 - 366338951777484*x**3 - 1626952264533540*x**2 + 3165484529481687*x - 49432656329674803)/2290213103040
            lambx = (x**11 - 18748179)/65124 # it is not an integer
            m = 2814
            m == 2 * 3 * 7 * 67
            u_mod_m = [57, 519, 855, 1023, 1275, 1317, 1401, 1569, 2157, 2241, 2661]
            # [2157, 2661], [57, 519, 855, 1023, 1275, 1317, 1401, 1569, 2241]
            u0_mod_67 = [13, 48]
            u1_mod_67 = [2, 18, 28, 30, 44, 50, 51, 57, 61]
            if choice is None or choice == 0:
                u_mod_m = [2157, 2661]
            else:
                u_mod_m = [57, 519, 855, 1023, 1275, 1317, 1401, 1569, 2241]
                rx = rx / 67
                cx = cx * 67
        elif D == 1:
            D = 1
            px = (x**24 - 2*x**23 + 5*x**22 + 12938*x**13 - 47012*x**12 + 64690*x**11 + 48828125*x**2 - 206464378*x + 244140625)/139603280
            rx = (x**20 - 2*x**19 - x**18 + 12*x**17 - 19*x**16 - 22*x**15 + 139*x**14 - 168*x**13 - 359*x**12 + 1558*x**11 - 1321*x**10 + 7790*x**9 - 8975*x**8 - 21000*x**7 + 86875*x**6 - 68750*x**5 - 296875*x**4 + 937500*x**3 - 390625*x**2 - 3906250*x + 9765625)/1321
            tx = (-x**12 - 5148*x + 6605)/6605
            yx = (x**12 - 5*x**11 + 11753*x - 32345)/13210
            cx = (x**4 + 6*x**2 + 25)/105680
            betax = (41*x**23 - 199*x**22 + 644*x**21 - 1580*x**20 + 3220*x**19 - 7900*x**18 + 16100*x**17 - 39500*x**16 + 80500*x**15 - 197500*x**14 + 402500*x**13 - 457042*x**12 - 1196242*x**11 + 5402492*x**10 - 12387460*x**9 + 27012460*x**8 - 61937300*x**7 + 135062300*x**6 - 309686500*x**5 + 675311500*x**4 - 1548432500*x**3 + 3376557500*x**2 - 5740209375*x + 4208874001)/614254432
            lambx = (x**11 + 6469)/2642
            m = 13210
            u_mod_m = [513, 10053,     2013, 4313, 5673, 9533, 9663, 9753, 9983, 10673, 11053]
            u0_mod_1321 = [513, 806]
            u1_mod_1321 = [105, 286, 350, 389, 416, 485, 506, 692, 736]
            if choice is None or choice == 0:
                u_mod_m = [513, 10053] # so that r can be prime
            else:
                u_mod_m = [2013, 4313, 5673, 9533, 9663, 9753, 9983, 10673, 11053]
                rx = rx / 1321
                cx = cx * 1321
    elif k == 28 and (D is None or D == 1):
        D = 1
        m = 2030
        px = (x**16 - 2*x**15 + 5*x**14 + 556*x**9 - 1344*x**8 + 2780*x**7 + 78125*x**2 - 217382*x + 390625)/16820
        rx = (x**12 + 4*x**11 + 11*x**10 + 24*x**9 + 41*x**8 + 44*x**7 - 29*x**6 + 220*x**5 + 1025*x**4 + 3000*x**3 + 6875*x**2 + 12500*x + 15625)/29
        tx = (-2*x**8 - 527*x + 145)/145
        yx = (-x**8 + 5*x**7 - 336*x + 1390)/145
        cx = (x**4 - 6*x**3 + 18*x**2 - 30*x + 25)/580
        assert cx == (x**2 - 4*x + 5) * (x**2 - 2*x + 5) / 580 # same as GG20a
        lambx = (x**7 + 278)/29
        betax = (13*x**15 - 57*x**14 + 192*x**13 - 440*x**12 + 960*x**11 - 2200*x**10 + 4800*x**9 - 3772*x**8 - 9722*x**7 + 56972*x**6 - 129860*x**5 + 284860*x**4 - 649300*x**3 + 1424300*x**2 - 2230875*x + 2147767)/28594
        # the following constraints also ensure that p = 1 mod 7
        if choice is None or choice == 0:
            u_mod_m = [309, 449, 1759, 1899] # so that rx can take prime values
        elif choice == 1:
            u_mod_m = [79, 359, 379, 659, 939, 989, 1409, 1569, 1829, 1989]
            rx = rx/29
            cx = cx*29
        elif choice == 2:
            u_mod_m = [135, 275, 715, 855]
            rx = rx/5**6
            cx = cx*5**6
        elif choice == 3:
            u_mod_m = [205, 365, 485, 765, 785, 1065, 1345, 1395, 1815, 1975]
            rx = rx / (5**6 * 29)
            cx = cx * 5**6 * 29

    elif k == 28 and D == 11:
        D = 11
        px = (x**30 + x**29 + 3*x**28 + 2515*x**16 + 14384*x**15 + 7545*x**14 + 4782969*x**2 + 13304911*x + 14348907)/38419953
        rx = (x**24 + 5*x**22 + 16*x**20 + 35*x**18 + 31*x**16 - 160*x**14 - 1079*x**12 - 1440*x**10 + 2511*x**8 + 25515*x**6 + 104976*x**4 + 295245*x**2 + 531441)/(3**12 * 13**2 * 83**2)
        tx = (x**15 + 718*x + 3237)/3237
        yx = (-x**15 - 6*x**14 - 7192*x - 7545)/35607
        cx = (x**6 + x**5 - 2*x**4 - 5*x**3 - 6*x**2 + 9*x + 27)*3**11/11
        lambx = (x**14 + 718)/1079
        betax = (13*x**29 - 22*x**28 + 43*x**27 - 171*x**26 + 129*x**25 - 513*x**24 + 387*x**23 - 1539*x**22 + 1161*x**21 - 4617*x**20 + 3483*x**19 - 13851*x**18 + 10449*x**17 - 41553*x**16 + 64042*x**15 + 33902*x**14 - 153635*x**13 + 16413*x**12 - 460905*x**11 + 49239*x**10 - 1382715*x**9 + 147717*x**8 - 4148145*x**7 + 443151*x**6 - 12444435*x**5 + 1329453*x**4 - 37333305*x**3 + 3988359*x**2 - 49821318*x + 60313497)/64301926
        m = 35607
        u_mod_m = [5076, 9366, 13293, 17583]
    elif k == 46 and (D is None or D == 7) and (choice is None or choice in [0,1]):
        px = (x**48 + x**47 + 2*x**46 + 5197*x**25 + 11966*x**24 + 10394*x**23 + 8388608*x**2 + 22705043*x + 16777216)/13091246
        rx = (x**44 + x**43 - x**42 - 3*x**41 - x**40 + 5*x**39 + 7*x**38 - 3*x**37 - 17*x**36 - 11*x**35 + 23*x**34 + 45*x**33 - x**32 - 91*x**31 - 89*x**30 + 93*x**29 + 271*x**28 + 85*x**27 - 457*x**26 - 627*x**25 + 287*x**24 + 1541*x**23 + 967*x**22 + 3082*x**21 + 1148*x**20 - 5016*x**19 - 7312*x**18 + 2720*x**17 + 17344*x**16 + 11904*x**15 - 22784*x**14 - 46592*x**13 - 1024*x**12 + 92160*x**11 + 94208*x**10 - 90112*x**9 - 278528*x**8 - 98304*x**7 + 458752*x**6 + 655360*x**5 - 262144*x**4 - 1572864*x**3 - 1048576*x**2 + 2097152*x + 4194304)/967
        tx = (x**24 + 2115*x + 1934)/1934
        yx = (-x**24 - 4*x**23 - 5983*x - 10394)/13538
        cx = (x**4 + 3*x**2 + 4)/13538 # 2*7*967
        assert cx == (x**2 + x + 2)*(x**2 - x + 2)/(2*7*967)
        # 2 always divides each factor: 2 | (x^2+x+2) and 2 | (x^2-x+2)
        # x = 3 mod 7 => 7 divides (x^2 + x + 2)
        # x = 268, 700 mod 967 => 967 divides (x^2-x+2)
        lambx = (x**23 + 2115)/967
        betax = (67*x**47 + 20*x**46 + 221*x**45 - 54*x**44 + 442*x**43 - 108*x**42 + 884*x**41 - 216*x**40 + 1768*x**39 - 432*x**38 + 3536*x**37 - 864*x**36 + 7072*x**35 - 1728*x**34 + 14144*x**33 - 3456*x**32 + 28288*x**31 - 6912*x**30 + 56576*x**29 - 13824*x**28 + 113152*x**27 - 27648*x**26 + 226304*x**25 + 292903*x**24 + 705466*x**23 + 415197*x**22 + 313204*x**21 + 830394*x**20 + 626408*x**19 + 1660788*x**18 + 1252816*x**17 + 3321576*x**16 + 2505632*x**15 + 6643152*x**14 + 5011264*x**13 + 13286304*x**12 + 10022528*x**11 + 26572608*x**10 + 20045056*x**9 + 53145216*x**8 + 40090112*x**7 + 106290432*x**6 + 80180224*x**5 + 212580864*x**4 + 160360448*x**3 + 425161728*x**2 + 882757632*x + 1038504151)/294553035
        D = 7
        m = 6769
        if choice is None or choice == 0:
            u_mod_m = [1235, 3601] # [268, 700] mod 967
        else:
            u_mod_m = [864, 1046, 1277, 1795, 2733, 2740, 3020, 3517, 3818, 4343, 4497, 4700, 4721, 4791, 4847, 5155, 5190, 5253, 5330, 5918, 6639]
            rx = rx/967
            cx = cx*967
    elif k == 46 and D == 15 and (choice is None or choice in [2,3]):
        # x = 0 mod 3
        # x = 4 mod 5
        # x = mod 47^2
        px = (x**48 - 3*x**47 + 6*x**46 - 928427427*x**25 + 8655048126*x**24 - 5570564562*x**23 + 789730223053602816*x**2 - 1648601361930867453*x + 4738381338321616896)/13781660430051425610
        rx = (x**44 - 3*x**43 + 3*x**42 + 9*x**41 - 45*x**40 + 81*x**39 + 27*x**38 - 567*x**37 + 1539*x**36 - 1215*x**35 - 5589*x**34 + 24057*x**33 - 38637*x**32 - 28431*x**31 + 317115*x**30 - 780759*x**29 + 439587*x**28 + 3365793*x**27 - 12734901*x**26 + 18009945*x**25 + 22379571*x**24 - 175198383*x**23 + 391317723*x**22 - 1051190298*x**21 + 805664556*x**20 + 3890148120*x**19 - 16504431696*x**18 + 26172406368*x**17 + 20509371072*x**16 - 218562551424*x**15 + 532631427840*x**14 - 286518974976*x**13 - 2336231642112*x**12 + 8727808776192*x**11 - 12166036475904*x**10 - 15868743229440*x**9 + 120602448543744*x**8 - 266594886254592*x**7 + 76169967501312*x**6 + 1371059415023616*x**5 - 4570198050078720*x**4 + 5484237660094464*x**3 + 10968475320188928*x**2 - 65810851921133568*x + 131621703842267136)/69320760676281
        tx = (x**24 + 122762871*x + 2347906338)/2347906338
        yx = (-x**24 + 4*x**23 + 1442508021*x - 1856854854)/11739531690
        cx = (x**4 + 3*x**2 + 36)/(2 * 3**2 * 5 * 47**2)
        cxa = (x**2 - 3*x + 6)/(2*3*5)
        cxb = (x**2 + 3*x + 6)/(2*3*47**2)
        # if x = 4 mod 5, 5 | cxa
        # if x = 459, 1747 mod 47^2, 47^2 | cxb
        lambx = (x**23 - 659872575)/391317723
        betax = (43*x**47 - 136*x**46 + 537*x**45 - 858*x**44 + 3222*x**43 - 5148*x**42 + 19332*x**41 - 30888*x**40 + 115992*x**39 - 185328*x**38 + 695952*x**37 - 1111968*x**36 + 4175712*x**35 - 6671808*x**34 + 25054272*x**33 - 40030848*x**32 + 150325632*x**31 - 240185088*x**30 + 901953792*x**29 - 1441110528*x**28 + 5411722752*x**27 - 8646663168*x**26 + 32470336512*x**25 - 91802358369*x**24 + 379785807594*x**23 - 269826944607*x**22 + 1155495160188*x**21 - 1618961667642*x**20 + 6932970961128*x**19 - 9713770005852*x**18 + 41597825766768*x**17 - 58282620035112*x**16 + 249586954600608*x**15 - 349695720210672*x**14 + 1497521727603648*x**13 - 2098174321264032*x**12 + 8985130365621888*x**11 - 12589045927584192*x**10 + 53910782193731328*x**9 - 75534275565505152*x**8 + 323464693162387968*x**7 - 453205653393030912*x**6 + 1940788158974327808*x**5 - 2719233920358185472*x**4 + 11644728953845966848*x**3 - 16315403522149112832*x**2 + 103826773314380722176*x - 122290706030602409163)/75799132365282840855
        m = 33135
        # 0 mod 3
        # 4 mod 5
        # [28, 158, 173, 333, 459, 576, 990, 996, 1134, 1170, 1238, 1337, 1484, 1541, 1553, 1663, 1747, 1811, 1981, 1988, 2022, 2149, 2186] mod 47^2
        u_mod_m = [459, 576, 996, 1134, 3546, 4446, 6081, 6399, 7086, 7761, 8649, 8994, 9009, 10074, 10389, 10824, 13026, 13194, 14244, 14424, 15276, 15621, 15636, 16701, 17004, 17016, 17274, 17451, 17649, 19419, 19821, 20214, 20871, 21051, 23574, 23631, 23901, 24276, 26046, 26841, 27084, 27504, 30054, 30201, 30954, 32589]
        if choice is None or choice == 2:
            u_mod_m = [459, 19419] # rx can take prime values
            # corresponds to [459, 1747] mod 47^2
        else:
            # 47^2 | r
            u_mod_m = [1134, 6399, 8649, 8994, 9009, 10074, 10389, 10824, 13194, 14244, 14424, 17004, 17274, 17649, 20214, 23574, 27084, 27504, 30054, 30954, 32589]
            # corresponds to [28, 158, 173, 333, 576, 990, 996, 1134, 1170, 1238, 1337, 1484, 1541, 1553, 1663, 1811, 1981, 1988, 2022, 2149, 2186] mod 47^2
            rx = rx / 47**2
            cx = cx * 47**2
            cxb = cxb * 47**2
    assert (px+1-tx) == cx*rx
    assert (tx**2 + D*yx**2) == 4*px
    if D == 1 or D == 4:
        assert ((betax**2 + 1) % px) == 0
        assert ((lambx**2 + 1) % rx) == 0
    elif D == 3:
        assert ((betax**2 + betax + 1) % px) == 0
        assert ((lambx**2 + lambx + 1) % rx) == 0
    elif betax is not None and lambx is not None:
        if (D % 4) == 1:
            assert ((betax**2 + D) % px) == 0
            assert ((lambx**2 + D) % rx) == 0
        elif (D % 4) == 3:
            assert ((betax**2 + betax + (D+1)//4) % px) == 0
            assert ((lambx**2 + lambx + (D+1)//4) % rx) == 0

    return px, rx, tx, cx, yx, betax, lambx, D

def coeffs_params(k, D=None, choice=None):
    px, rx, tx, cx, yx, betax, lambx, D = polynomial_params(k, D, choice)
    Px_denom = Integer(lcm([ci.denom() for ci in px.list()]))
    Px = [Integer(ci) for ci in (Px_denom*px).list()]
    Rx_denom = Integer(lcm([ci.denom() for ci in rx.list()]))
    Rx = [Integer(ci) for ci in (Rx_denom*rx).list()]
    Tx_denom = Integer(lcm([ci.denom() for ci in tx.list()]))
    Tx = [Integer(ci) for ci in (Tx_denom*tx).list()]
    Cx_denom = Integer(lcm([ci.denom() for ci in cx.list()]))
    Cx = [Integer(ci) for ci in (Cx_denom*cx).list()]
    Yx_denom = Integer(lcm([ci.denom() for ci in yx.list()]))
    Yx = [Integer(ci) for ci in (Yx_denom*yx).list()]
    if betax is not None and lambx is not None and betax != 0 and lambx != 0:
        BETAx_denom = Integer(lcm([ci.denom() for ci in betax.list()]))
        BETAx = [Integer(ci) for ci in (BETAx_denom*betax).list()]
        LAMBx_denom = Integer(lcm([ci.denom() for ci in lambx.list()]))
        LAMBx = [Integer(ci) for ci in (LAMBx_denom*lambx).list()]
    else:
        BETAx_denom=0; BETAx=0; LAMBx_denom=0; LAMBx=0
    return Px, Px_denom, Rx, Rx_denom, Tx, Tx_denom, Cx, Cx_denom, Yx, Yx_denom, BETAx, BETAx_denom, LAMBx, LAMBx_denom, D

def poly_cofactor_gt(k, choice=None, D=None):
    """Computes the co-factors for GT: Phi_k(p(x))/r(x)
    It is always irreducible:
    from tnfs.curve.gg import poly_cofactor_gt
    for k in [8,16,18,32,36,40,54]:
        print("\nGG-{}".format(k))
        c = poly_cofactor_gt(k)
        print(["(deg {})^{} ".format(ci.degree(), ei) if ei>1 else "(deg {})".format(ci.degree()) for (ci, ei) in c.factor()])
        print(lcm([ci.denom() for ci in c.list()]))
    """
    QQx = QQ['x']; (x,) = QQx._first_ngens(1)
    px, rx, tx, cx, yx, betax, lambx, D = polynomial_params(k, D, choice)
    cx = cyclotomic_polynomial(k)(px)
    assert (cx % rx) == 0
    cx = cx // rx
    return cx

def poly_cofactor_twist_g1_g2(k, D=None, choice=None):
    QQx = QQ['x']; (x,) = QQx._first_ngens(1)
    px, rx, tx, cx, yx, betax, lambx, D = polynomial_params(k, D, choice)
    twx = px+1+tx
    if k == 8:
        # for G2: quartic twist over Fp2
        tx2 = tx**2 - 2*px
        px2 = px**2
        assert (px2 + 1 - tx2) == (px+1-tx)*(px+1+tx)
        yx2 = tx*yx
        assert tx2**2 - 4*px2 == -D*yx2**2
        # now the 4-th twist that matches rx
        if D == 1:
            E2_order = px2 + 1 + yx2
            g2twx = px2 + 1 - yx2
        elif D == 4:
            E2_order = px2 + 1 + 2*yx2
            g2twx = px2 + 1 - 2*yx2
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # irreducible
        m = 30
        #u_m = [5,7,17,19,25,29]
        #cofactor_r = [450, 18, 18, 18, 450, 18] # cofactor of r according to u_m
        #cofactor_r = [25, 1, 1, 1, 25, 1] # cofactor of r according to u_m
        u_m = [5, 25]
        cofactor_r = [1, 1]
        polys_cofact_twists = [cx, twx, g2cx, g2twx]
        label_factors = ["cx", "twx", "g2cx", "g2twx"]
        small_cofactors = [1, 1, 1, 1]

    elif k == 16:
        if (D is None or D in [1, 4]) and (choice is None or choice in [0, 1, 2, 3]):
            # for G2: quartic twist over Fp4
            px2 = px**2
            px4 = (px2)**2
            tx2 = tx**2 - 2*px
            tx4 = tx2**2 - 2*px2
            assert (px4 + 1 - tx4) == (px+1-tx)*(px+1+tx)*(px2+1+tx2)
            yx4 = yx*tx*(tx**2-2*px)
            assert tx4**2 - 4*px4 == -D*yx4**2
            # now the 4-th twist that matches rx
            if D == 4:
                E2_order = px4 + 1 + 2*yx4
                g2twx = px4 + 1 - 2*yx4
            elif D == 1:
                E2_order = px4 + 1 + yx4
                g2twx = px4 + 1 - yx4
            assert (E2_order % rx) == 0
            g2cx = E2_order // rx # irreducible
            if choice is None or choice == 0:
                m = 70 # we should have u = 25,45 mod 70 <=> +/- 25 mod 70
                u_m = [25, 45] # 25 or 45
                cofactor_r = [1, 1]
                polys_cofact_twists = [cx, twx, g2cx, g2twx]
                label_factors = ["cx", "twx", "g2cx", "g2twx"]
                small_cofactors = [1, 1, 1, 1]
            elif choice == 1:
                m = 3094
                u_m = [13, 169, 715, 897, 2197, 2379, 2925, 3081]
                cofactor_r = [1]*len(u_m)
                polys_cofact_twists = [cx, twx, g2cx, g2twx]
                label_factors = ["cx", "twx", "g2cx", "g2twx"]
                small_cofactors = [57122, 1, 1, 1]
            elif choice == 2:
                m = 26350
                u_m = [925, 2475, 8375, 11775, 14575, 17975, 23875, 25425]
                cofactor_r = [1]*len(u_m)
                polys_cofact_twists = [cx, twx, g2cx, g2twx]
                label_factors = ["cx", "twx", "g2cx", "g2twx"]
                small_cofactors = [781250, 1, 1, 1]
            elif choice == 3:
                m = 80782
                u_m = [24843, 55939]
                cofactor_r = [1]*len(u_m)
                polys_cofact_twists = [cx, twx, g2cx, g2twx]
                label_factors = ["cx", "twx", "g2cx", "g2twx"]
                small_cofactors = [1631461442, 1, 1, 1]
        else: # D = 35, D=227
            # for G2: quadratic twist over Fp8
            px2 = px**2
            px4 = (px2)**2
            px8 = (px4)**2
            tx2 = tx**2 - 2*px
            tx4 = tx2**2 - 2*px2
            tx8 = tx4**2 - 2*px4
            assert (px8  + 1 - tx8) == (px+1-tx)*(px+1+tx)*(px2+1+tx2)*(px4+1+tx4)
            # the quadratic twist that matches rx
            E2_order = px8  + 1 + tx8
            assert (E2_order % rx) == 0
            g2cx = E2_order // rx # irreducible
            g2twx = None
            if D == 35:
                m = 680085
                u_m = [1908, 41913, 74673, 114678, 121923, 194688, 234693, 281943, 314703, 321948, 474723, 481968, 514728, 561978, 601983, 674748]
                #m = 1360170
                #u_m = [3816, 83826, 149346, 229356, 243846, 389376, 469386, 563886, 629406, 643896, 949446, 963936, 1029456, 1123956, 1203966, 1349496]
                cxa = (x**2 - x + 9)/315
                assert cxa == cx/43046721
            elif D == 227:
                m = 9168872997
                u_m = [547293936, 681251403, 843532341, 1277558157, 2872044066, 2981508006, 3602308287, 3711772227, 5306258136, 5740283952, 5902564890, 6036522357, 7525374270, 7687655208, 8065034082, 8227315020]
                cxa = (x**2 - x + 57)/12939
                assert cxa == cx / 111429157112001
            cofactor_r = [1]*len(u_m)
            polys_cofact_twists = [cxa, twx, g2cx]
            label_factors = ["cx", "twx", "g2cx"]
            small_cofactors = [1, 1, 1]

    elif k == 18:
        # it is working for both choice=0 and choice=1
        # for G2: sextic twist over Fp3
        px2 = px**2
        tx2 = tx**2 - 2*px
        tx3 = tx*tx2 - px*tx
        px3 = px*px2
        yx3 = yx * (px - tx**2)
        assert (tx3**2 - 4*px3) == -D*yx3**2
        # now the 6-th twist that matches rx
        E2_order = px3+1-( 3*yx3+tx3)/2
        g2twx = px3+1+( 3*yx3+tx3)/2
        if (E2_order % rx) != 0:
            E2_order = px3+1-(-3*yx3+tx3)/2
            g2twx = px3+1-(-3*yx3+tx3)/2
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # irreducible
        # for px(u) to be an integer we need u = 5,7,14,19 mod 21 but for u_m = 7, 19 then 3 | px(21*x+u_m)
        # for rx(u) to be an integer we need u = 0,7,14 mod 21 (u=0 mod 7) and 3 | rx(21*x + 7)
        if choice is None or choice in [0, 1]:
            m = 21
            u_m = [14] # 14 mod 21 only. With 7 mod 21, px is always multiple of 3.
        elif choice in [2,3,4]:
            m = 357
            u_m = [189]
        elif choice in [5,6]:
            m = 399
            u_m = [7, 49, 343]
        elif choice in [7, 8]:
            m = 663
            u_m = [247]
        else:
            m = 21
            u_m = [14]
        cofactor_r = [1]
        polys_cofact_twists = [cx, twx, g2cx, g2twx]
        label_factors = ["cx", "twx", "g2cx", "g2twx"]
        if choice is None or choice in [0,1]:
            small_cofactors = [343, 3, 3, 1]
        else:
            small_cofactors = [1, 1, 1, 1]

    elif k == 20:
        # it is working for both choice=0 and choice=1
        # for G2: quartic twist over Fp5
        px2 = px**2
        px4 = (px2)**2
        px5 = px*px4
        tx2 = tx**2 - 2*px
        tx3 = tx*tx2 - px*tx
        tx4 = tx2**2 - 2*px2
        assert tx4 == tx*tx3 - px*tx2
        tx5 = tx*tx4 - px*tx3
        assert tx5 == tx**5 - 5*px*tx**3 + 5*px**2*tx
        #assert (px5 + 1 - tx5) == (px+1-tx)*(q^4 + q^3*t + q^2*t^2 + q*t^3 + t^4 - q^3 - 2*q^2*t - 3*q*t^2 + t^3 + q^2 - 2*q*t + t^2 - q + t + 1)
        assert (px5 + 1 - tx5) % (px+1-tx) == 0
        yx5 = yx * (5*tx**4 - 10*tx**2*yx**2 + yx**4)/16
        assert tx5**2 - 4*px5 == -D*yx5**2
        # now the 4-th twist that matches rx
        if D == 4:
            E2_order = px5 + 1 + 2*yx5
            g2twx = px5 + 1 - 2*yx5
        elif D == 1:
            E2_order = px5 + 1 + yx5
            g2twx = px5 + 1 - yx5
        assert (E2_order % rx) == 0
        m = 2050 # 2*5**2*41
        if choice is None or choice == 0:
            #u_m = [315, 1365, 1715, 1815, 1965]
            #cofactor_r = [41, 41, 1, 1, 41]
            u_m = [1715, 1815]
            cofactor_r = [1, 1]
            cx0 = 15625
            cxa = (x**2 - 4*x + 5)/(2*5*41)
            cxb = (x**2 - 2*x + 5)/(2*5**2)
            assert cx == cx0*cxa*cxb
        else:
            #u_m = [915, 1315, 1465, 1565, 1915]
            #cofactor_r = [41,41,1,1,41]
            u_m = [1465, 1565]
            cofactor_r = [1, 1]
            cx0 = 15625
            cxa = (x**2 + 4*x + 5)/(2*5*41)
            cxb = (x**2 - 2*x + 5)/(2*5**2)
            assert cx == cx0*cxa*cxb
        g2cx = E2_order // rx # reducible with 3 factors
        if choice is None or choice == 0:
            # let's assume u = 1715, 1815 mod 2050 so that r can be prime: then
            g2cxa = (x**2 - 4*x + 5)/410
            g2cxb = (x**10 + 2*x**9 + 8*x**8 + 22*x**7 + 48*x**6 + 158*x**5 + 732*x**4 + 1698*x**3 + 3132*x**2 + 4038*x + 3617)/164
        else:
            # let's assume u = 1465, 1565 mod 2050 so that r can be prime: then
            g2cxa = (x**2 + 4*x + 5)/410
            g2cxb = (x**10 - 6*x**9 + 24*x**8 - 66*x**7 + 144*x**6 - 322*x**5 + 556*x**4 - 1814*x**3 + 4476*x**2 - 8834*x + 16081)/164
        g2cxc = g2cx // (g2cxa*g2cxb)
        cofactor_r = [1, 1]
        polys_cofact_twists = [cxa, cxb, twx, g2cxa, g2cxb, g2cxc, g2twx]
        label_factors = ["cxa", "cxb", "twx", "g2cxa", "g2cxb", "g2cxc", "g2twx"]
        small_cofactors = [1, 1, 1, 1, 1, 2, 1] # the cofactors of the above polynomials in polys_cofact_twists

    elif k == 22:
        px2 = px**2
        tx2 = tx**2 - 2*px
        tx3 = tx*tx2 - px*tx
        tx4 = tx2**2 - 2*px2
        assert tx4 == tx*tx3 - px*tx2
        tx5 = tx*tx4 - px*tx3
        tx6 = tx*tx5 - px*tx4
        tx7 = tx*tx6 - px*tx5
        tx8 = tx*tx7 - px*tx6
        tx9 = tx*tx8 - px*tx7
        tx10 = tx*tx9 - px*tx8
        tx11 = tx*tx10 - px*tx9
        E2_order = px**11 + 1 + tx11
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # reducible with 3 factors
        if D is None or D == 7:
            if choice is None or choice in [0, 1]:
                m = 161
                cxa = (x**2 - x + 2)/7
                cxb = (x**2 + x + 2)
                g2cxa = (x**2 + x + 2)
                g2cxb = (x**22 - 2*x**21 + 2*x**20 + 2*x**19 - 6*x**18 + 2*x**17 + 10*x**16 - 14*x**15 - 6*x**14 + 34*x**13 - 22*x**12 + 21*x**11 + 278*x**10 - 186*x**9 - 370*x**8 + 742*x**7 - 2*x**6 - 1482*x**5 + 1486*x**4 + 1478*x**3 - 4450*x**2 + 1494*x + 9454)/(7 * 23)
                if choice is None or choice == 0:
                    u_m = [32, 151]
                    cxb = cxb/23
                    g2cxa = g2cxa/23
                else:
                    u_m = [4,18,25,39,81,95,116,123,144]
                    g2cxb = g2cxb/23
                g2cxc = g2cx//(g2cxa*g2cxb)
            else: # if choice in [2, 3]:
                m = 5159
                # cx divided by 2 * 7^2 * 67
                cxa = (x**2 - 7*x + 14)/14
                cxb = (x**2 + 7*x + 14)/7
                g2cxa = (x**2 + 7*x + 14)/14
                g2cxb = (x**22 - 14*x**21 + 98*x**20 - 490*x**19 + 2058*x**18 - 7546*x**17 + 24010*x**16 - 62426*x**15 + 100842*x**14 + 168070*x**13 - 2588278*x**12 + 13059039*x**11 - 52000858*x**10 + 143296482*x**9 - 275063362*x**8 - 80707214*x**7 + 4415837566*x**6 - 29780961966*x**5 + 146645007838*x**4 - 609581587342*x**3 + 2214041001662*x**2 - 6964144788846*x + 21802004668318)/(7**11*67)
                if choice == 2:
                    u_m = [2933, 3626]
                    cxb = cxb/67
                    g2cxa = g2cxa/67
                else:
                    u_m = [161, 1008, 1316, 1393, 2009, 2856, 3087, 3395, 4011]
                    g2cxb = g2cxb/67
                g2cxc = g2cx//(g2cxa*g2cxb)
        elif D == 3:
            cxa = (x**2 - 6*x + 21)/12
            cxb = (x**2 + 6*x + 21)/84
            g2cxa = (x**2 + 6*x + 21)/84
            g2cxb = (x**22 - 12*x**21 + 72*x**20 - 180*x**19 - 432*x**18 + 6372*x**17 - 29160*x**16 + 41148*x**15 + 365472*x**14 - 3056940*x**13 + 10666728*x**12 - 37235862*x**11 + 222438312*x**10 - 1338732684*x**9 + 3361191552*x**8 + 7946237052*x**7 - 118262444904*x**6 + 542703691332*x**5 - 772710805008*x**4 - 6760512687924*x**3 + 56790003032712*x**2 - 198769251749868*x + 350302947354477)/996983316
            g2cxc = g2cx//(g2cxa*g2cxb)
            m = 2814
            if choice is None or choice == 0:
                u_m = [2157, 2661]
                cxb = cxb / 67
                g2cxa = g2cxa / 67
            else:
                u_m = [57, 519, 855, 1023, 1275, 1317, 1401, 1569, 2241]
                g2cxb = g2cxb / 67
        elif D == 1:
            cxa = (x**2 - 2*x + 5)/4
            cxb = (x**2 + 2*x + 5)/20
            g2cxa = (x**2 + 2*x + 5)/20
            g2cxb = (x**22 - 4*x**21 + 8*x**20 + 4*x**19 - 48*x**18 + 76*x**17 + 88*x**16 - 556*x**15 + 672*x**14 + 1436*x**13 - 6232*x**12 + 18222*x**11 - 73432*x**10 + 120444*x**9 + 126272*x**8 - 854764*x**7 + 1078168*x**6 + 2117484*x**5 - 9625808*x**4 + 8664196*x**3 + 30800648*x**2 - 104922276*x + 104669437)/26420
            g2cxc = g2cx // (g2cxa * g2cxb)
            m = 13210
            if choice is None or choice == 0:
                u_m = [513, 10053]
                cxb = cxb / 1321
                g2cxa = g2cxa / 1321
            else:
                u_m = [2013, 4313, 5673, 9533, 9663, 9753, 9983, 10673, 11053]
                g2cxb = g2cxb / 1321
        cofactor_r = [1]*len(u_m)
        small_cofactors = [1]*len(u_m)
        polys_cofact_twists = [cx, cxa, cxb, twx, g2cxa, g2cxb]#, g2cxc]
        label_factors = ["cx", "cxa", "cxb", "twx", "g2cxa", "g2cxb"]#, "g2cxc"]
        g2twx = None

    elif k == 28 and (D is None or D == 1):
        # quartic twist
        # go up to 7
        tx7 = tx**7 - 7*px*tx**5 + 14*px**2*tx**3 - 7*px**3*tx
        yx7 = yx * (tx**6 - 5*px*tx**4 + 6*px**2*tx**2 - px**3)
        E2_order = px**7 + 1 + yx7
        g2twx = px**7 + 1 - yx7
        if not (E2_order % rx) == 0:
            E2_order = px**7 + 1 - yx7
            g2twx = px**7 + 1 + yx7
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx
        # twx == (x**16 + 2*x**15 + 5*x**14 + 556*x**9 + 1576*x**8 + 2780*x**7 + 78125*x**2 + 278514*x + 424265)/16820
        # irreducible
        cxa = (x**2 - 4*x + 5)
        cxb = (x**2 - 2*x + 5)
        g2cxa = (x**2 - 4*x + 5)
        g2cxb = (x**14 + 6*x**13 + 24*x**12 + 66*x**11 + 144*x**10 + 246*x**9 + 264*x**8 + 382*x**7 + 1436*x**6 + 6034*x**5 + 16956*x**4 + 37654*x**3 + 65836*x**2 + 75074*x + 49241)
        g2cxc = g2cx//(g2cxa * g2cxb)
        g2twxa = (x**16 + 2*x**15 + 5*x**14 + 556*x**9 + 1460*x**8 + 3360*x**7 + 78125*x**2 + 256358*x + 568685)
        #g2twxb = g2twx // g2twxa
        m = 2030
        if choice is None or choice == 0:
            u_m = [309, 449, 1759, 1899] # so that rx can take prime values
        elif choice == 1:
            u_m = [79, 359, 379, 659, 939, 989, 1409, 1569, 1829, 1989]
        elif choice == 2:
            u_m = [135, 275, 715, 855]
        elif choice == 3:
            u_m = [205, 365, 485, 765, 785, 1065, 1345, 1395, 1815, 1975]
        cofactor_r = [1]*len(u_m)
        small_cofactors = [1]*len(u_m)
        polys_cofact_twists = [cxa, cxb, twx, g2cxb, g2twxa]
        label_factors = ["cxa", "cxb", "twx", "g2cxb", "g2twxa"]

    elif k == 28 and D == 11:
        # quadratic twist
        # go up to 14
        tx14 = tx**14 - 14*px*tx**12 + 77*px**2*tx**10 - 210*px**3*tx**8 + 294*px**4*tx**6 - 196*px**5*tx**4 + 49*px**6*tx**2 - 2*px**7
        E2_order = px**14 + 1 + tx14
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # reducible with 3 factors
        # degree 396 = 4 + 56 + 336
        cxa = (x**2 + x + 3)
        cxb = (x**4 - 5*x**2 + 9)
        # twx = (x**30 + x**29 + 3*x**28 + 2515*x**16 + 26253*x**15 + 7545*x**14 + 4782969*x**2 + 21826853*x + 91188813)/38419953
        g2cxa = (x**4 - 5*x**2 + 9)
        g2cxb = (x**56 + 2*x**55 + 12*x**54 + 16*x**53 + 60*x**52 + 62*x**51 + 192*x**50 + 166*x**49 + 420*x**48 + 272*x**47 + 372*x**46 - 134*x**45 - 1920*x**44 - 3118*x**43 - 7918*x**42 + 19414*x**41 + 36638*x**40 + 226526*x**39 + 299722*x**38 + 957904*x**37 + 1168868*x**36 + 2750786*x**35 + 3146842*x**34 + 5132794*x**33 + 5214398*x**32 + 906896*x**31 - 2249588*x**30 - 41660666*x**29 - 42286359*x**28 - 107938114*x**27 + 201704008*x**26 + 83997358*x**25 + 1301598020*x**24 + 1391429816*x**23 + 4692654028*x**22 + 6201172858*x**21 + 11748887960*x**20 + 18482995946*x**19 + 16510553548*x**18 + 36604424008*x**17 - 23187223900*x**16 + 16675156526*x**15 - 240472767362*x**14 - 41543878920*x**13 - 457531642036*x**12 + 62512296642*x**11 - 486635388062*x**10 + 686456393490*x**9 + 1684607838014*x**8 + 2869671297672*x**7 + 12802757682628*x**6 + 8170248946950*x**5 + 48852317871014*x**4 + 15024203055702*x**3 + 129036770211418*x**2 + 1588774755960*x + 228389782672925)
        g2cxc = g2cxb // (g2cxa * g2cxb)
        m = 35607
        u_m = [5076, 9366, 13293, 17583]
        cofactor_r = [1]*len(u_m)
        small_cofactors = [1]*len(u_m)
        polys_cofact_twists = [cxa, cxb, twx, g2cxb]
        label_factors = ["cxa", "cxb", "twx", "g2cxb"]
        g2twx = None

    elif k == 32:
        # for G2: quartic twist over Fp8
        px2 = px**2
        px4 = (px2)**2
        px8 = (px4)**2
        tx2 = tx**2 - 2*px
        tx4 = tx2**2 - 2*px2
        tx8 = tx4**2 - 2*px4
        assert (px8 + 1 - tx8) == (px+1-tx)*(px+1+tx)*(px2+1+tx2)*(px4+1+tx4)
        #yx4 = yx*tx*(tx**2-2*px)
        #yx8 = yx * tx * (tx**2 - 2*px) * (tx**4 - 4*px*tx**2 + 2*px**2)
        yx8 = yx * tx * tx2 * tx4
        assert tx8**2 - 4*px8 == -D*yx8**2
        # now the 4-th twist that matches rx
        if D == 4:
            E2_order = px8 + 1 - 2*yx8
            g2twx = px8 + 1 + 2*yx8
        elif D == 1:
            E2_order = px8 + 1 - yx8
            g2twx = px8 + 1 + yx8
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # irreducible
        m = 6214
        u_m = [325, 5889] # 325 or 5889 = -325 mod 6214
        cofactor_r = [1, 1]
        polys_cofact_twists = [cx, twx, g2cx, g2twx]
        label_factors = ["cx", "twx", "g2cx", "g2twx"]
        small_cofactors = [1, 1, 1, 1]

    elif k == 36:
        # for G2: sextic twist over Fp6
        px2 = px**2
        px4 = px2**2
        px6 = px4*px2
        tx2 = tx**2 - 2*px
        tx4 = tx2**2 - 2*px2
        tx6 = tx2*tx4 - px2*tx2
        assert (px6 + 1 - tx6) == (px+1-tx)*(px+1+tx)*(px2+1+tx2 + px + tx*(px+1))*(px2+1+tx2 + px - tx*(px+1))
        yx6 = tx * yx * (tx**2 - 3*px) * (tx**2 - px)
        assert (tx6**2 - 4*px6) == -D*yx6**2
        # now the 6-th twist that matches rx
        E2_order = px6 + 1 - (-3*yx6 + tx6)/2
        g2twx = px6 + 1 +(-3*yx6+tx6)/2
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # irreducible
        m = 777
        u_m = [287, 308, 497, 539, 728, 749]
        # the denominator of tx is 7*37, the denominator of yx is 3*7*37, the denominator of px is 3*7*37^2
        # indeed for certain values of x mod 3*7*37^2, then px is not irreducible: x = 2093,
        # but it simplify a lot the description to consider the congruence equation modulo 3*7*37 = 777 only.
        # thanks to Jean Gasnier for discussions about it.
        cofactor_r = [1, 1, 1, 1, 1, 1]
        polys_cofact_twists = [cx, twx, g2cx, g2twx]
        label_factors = ["cx", "twx", "g2cx", "g2twx"]
        small_cofactors = [1]*len(u_m)

    elif k == 40:
        # cx = (78125/36) * (x^2 - 2*x + 5) * (x^4 - 8*x^2 + 25)
        cxa = (x**2 - 2*x + 5)/4
        cxb = (x**4 - 8*x**2 + 25)/18
        cx0 = 78125*2
        assert cx == cxa*cxb*cx0
        # for G2: quartic twist over Fp10
        px2 = px**2
        px4 = (px2)**2
        px5 = px4*px
        px10 = px5**2
        tx2 = tx**2 - 2*px
        tx3 = tx*tx2 - px*tx
        tx4 = tx*tx3 - px*tx2
        tx5 = tx*tx4 - px*tx3
        tx10 = tx5**2 - 2*px5
        assert (px10+1-tx10) == (px5+1-tx5) * (px5+1+tx5)
        #t^2 * (t^2 - 4*p) * (t^4 - 5*p*t^2 + 5*p^2)^2 * (t^4 - 3*p*t^2 + p^2)^2
        yx10 = yx * tx5 * (tx*tx3 + px2)
        assert tx10**2 - 4*px10 == -D*yx10**2
        # now the 4-th twist that matches rx
        if D == 4:
            E2_order = px10 + 1 + 2*yx10
            g2twx = px10 + 1 - 2*yx10
        elif D == 1:
            E2_order = px10 + 1 + yx10
            g2twx = px10 + 1 - yx10
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx
        # there are 3 parts
        g2cx0 = 2
        g2cxa = (x**4 - 8*x**2 + 25)/(25*18) # this is the same as cxb
        g2cxb = (x**40 - 4*x**39 + 22*x**38 - 52*x**37 + 176*x**36 - 316*x**35 + 858*x**34 - 1228*x**33 + 2464*x**32 - 1924*x**31 + 10726*x**30 - 30756*x**29 + 191120*x**28 - 428268*x**27 + 1572410*x**26 - 2657244*x**25 + 7801280*x**24 - 10551252*x**23 + 23099990*x**22 - 17978916*x**21 + 48136994*x**20 - 77629356*x**19 + 558361526*x**18 - 1168445628*x**17 + 4722694208*x**16 - 7406831124*x**15 + 23822515514*x**14 - 30043508292*x**13 + 72512768912*x**12 - 55177288236*x**11 + 106258013446*x**10 - 63737472620*x**9 + 548188465648*x**8 - 1053509178500*x**7 + 4766701317834*x**6 - 6834636612500*x**5 + 24428898901472*x**4 - 28339363437500*x**3 + 76263658265926*x**2 - 55848992187500*x + 94754225231233)/5608811664
        # arange for denominators
        g2cxc = g2cx // (g2cx0*g2cxa*g2cxb)

        g2twx0 = 2
        g2twxa = (x**44 - 4*x**43 + 14*x**42 - 20*x**41 + 25*x**40 + 12464*x**34 - 46064*x**33 + 166912*x**32 - 230320*x**31 + 311600*x**30 + 58369074*x**24 - 197579328*x**23 + 747170508*x**22 - 978909600*x**21 + 1459226850*x**20 + 121718750000*x**14 - 373406874032*x**13 + 1489818644656*x**12 - 1811027136880*x**11 + 3048293571200*x**10 + 95367431640625*x**4 - 261692148437500*x**3 + 1117837978524302*x**2 - 1220696679687500*x + 2402039916499225)/2523965248800
        g2twxb = g2twx // (g2twx0*g2twxa)

        m = 2370
        u_m = [415, 1165, 1205, 1955] # 1955 = 2370-415, 1205 = 2370-1165
        cofactor_r = [1, 1, 1, 1]
        polys_cofact_twists = [cx, twx, g2cxa, g2cxb, g2cxc, g2twxa, g2twxb]
        label_factors = ["cx", "twx", "g2cxa", "g2cxb", "g2cxc", "g2twxa", "g2twxb"]
        small_cofactors = [1, 1, 1, 1, 1, 1, 1]

    elif k == 46:
        tx23 = tx**23 - 23*px*tx**21 + 230*px**2*tx**19 - 1311*px**3*tx**17 + 4692*px**4*tx**15 - 10948*px**5*tx**13 + 16744*px**6*tx**11 - 16445*px**7*tx**9 + 9867*px**8*tx**7 - 3289*px**9*tx**5 + 506*px**10*tx**3 - 23*px**11*tx
        E2_order = px**23+1+tx23
        g2twx = px**23+1-tx23
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx
        if D is None or D == 7:
            D = 7
            m = 6769
            # twx = cxb * (degree 46)
            twxa = (x**2 - x + 2)
            twxb = (x**46 + 2*x**45 + 2*x**44 - 2*x**43 - 6*x**42 - 2*x**41 + 10*x**40 + 14*x**39 - 6*x**38 - 34*x**37 - 22*x**36 + 46*x**35 + 90*x**34 - 2*x**33 - 182*x**32 - 178*x**31 + 186*x**30 + 542*x**29 + 170*x**28 - 914*x**27 - 1254*x**26 + 574*x**25 + 3082*x**24 + 7131*x**23 + 19702*x**22 + 15834*x**21 - 23570*x**20 - 55238*x**19 - 8098*x**18 + 102378*x**17 + 118574*x**16 - 86182*x**15 - 323330*x**14 - 150966*x**13 + 495694*x**12 + 797626*x**11 - 193762*x**10 - 1789014*x**9 - 1401490*x**8 + 2176538*x**7 + 4979518*x**6 + 626442*x**5 - 9332594*x**4 - 10585478*x**3 + 8079710*x**2 + 29250666*x + 21479854)
            # twx = twa * twb / (2*7*967^2)
            # g2twx has degree 1104
            # g2cx has degree 2 + 46 + 1012
            g2cxa = (x**2 - x + 2)
            g2cxb = (x**46 + 2*x**45 + 2*x**44 - 2*x**43 - 6*x**42 - 2*x**41 + 10*x**40 + 14*x**39 - 6*x**38 - 34*x**37 - 22*x**36 + 46*x**35 + 90*x**34 - 2*x**33 - 182*x**32 - 178*x**31 + 186*x**30 + 542*x**29 + 170*x**28 - 914*x**27 - 1254*x**26 + 574*x**25 + 3082*x**24 + 7131*x**23 + 19702*x**22 + 15834*x**21 - 23570*x**20 - 55238*x**19 - 8098*x**18 + 102378*x**17 + 118574*x**16 - 86182*x**15 - 323330*x**14 - 150966*x**13 + 495694*x**12 + 797626*x**11 - 193762*x**10 - 1789014*x**9 - 1401490*x**8 + 2176538*x**7 + 4979518*x**6 + 626442*x**5 - 9332594*x**4 - 10585478*x**3 + 8079710*x**2 + 29250666*x + 21479854)
            g2cxc = g2cx // (g2cxa * g2cxb)
            if choice is None or choice == 0:
                u_m = [1235, 3601] # [268, 700] mod 967
                cofactor_r = [1, 1]
                cxa = (x**2+x+2)/(2*7)
                cxb = (x**2-x+2)/967
            elif choice == 1:
                u_m = [864, 1046, 1277, 1795, 2733, 2740, 3020, 3517, 3818, 4343, 4497, 4700, 4721, 4791, 4847, 5155, 5190, 5253, 5330, 5918, 6639]
                cofactor_r = [1]*len(u_m)
                cxa = (x**2+x+2)/(2*7)
                cxb = (x**2-x+2)
            polys_cofact_twists = [cxa, cxb, twxb, g2cxb] # g2cxa, g2cxb, g2cxc, g2twxa, g2twxb
            label_factors = ["cxa", "cxb", "twxb", "g2cxb"]
            small_cofactors = [1, 1, 1, 1]
        elif D == 15:
            m = 33135
            twxa = (x**2 + 3*x + 6)/(2*3*47**2)
            twxb = (x**46 - 6*x**45 + 18*x**44 - 18*x**43 - 54*x**42 + 270*x**41 - 486*x**40 - 162*x**39 + 3402*x**38 - 9234*x**37 + 7290*x**36 + 33534*x**35 - 144342*x**34 + 231822*x**33 + 170586*x**32 - 1902690*x**31 + 4684554*x**30 - 2637522*x**29 - 20194758*x**28 + 76409406*x**27 - 108059670*x**26 - 134277426*x**25 + 1051190298*x**24 - 3276333765*x**23 + 18046673478*x**22 - 40052582406*x**21 + 11877706350*x**20 + 204682375386*x**19 - 685313364258*x**18 + 827845840458*x**17 + 1628342664174*x**16 - 9852103035270*x**15 + 19786253120766*x**14 - 246141150678*x**13 - 117979095272562*x**12 + 355414132721754*x**11 - 358367826529890*x**10 - 1057381316740854*x**9 + 5322350909401902*x**8 - 9622764827760582*x**7 - 3065810973129666*x**6 + 66934021885952490*x**5 - 182407199819079474*x**4 + 145617468141523482*x**3 + 657590794489906398*x**2 - 2846477192318860086*x + 5383617033070744686)/(3**24 * 47**2 * 5)
            # denom of twx is 2 * 3^24 * 5 * 47^4
            # g2cx has degree 1060
            g2cxa = (x**2 + 3*x + 6)/(2*3*47**2)
            g2cxb = (x**46 - 6*x**45 + 18*x**44 - 18*x**43 - 54*x**42 + 270*x**41 - 486*x**40 - 162*x**39 + 3402*x**38 - 9234*x**37 + 7290*x**36 + 33534*x**35 - 144342*x**34 + 231822*x**33 + 170586*x**32 - 1902690*x**31 + 4684554*x**30 - 2637522*x**29 - 20194758*x**28 + 76409406*x**27 - 108059670*x**26 - 134277426*x**25 + 1051190298*x**24 - 3276333765*x**23 + 18046673478*x**22 - 40052582406*x**21 + 11877706350*x**20 + 204682375386*x**19 - 685313364258*x**18 + 827845840458*x**17 + 1628342664174*x**16 - 9852103035270*x**15 + 19786253120766*x**14 - 246141150678*x**13 - 117979095272562*x**12 + 355414132721754*x**11 - 358367826529890*x**10 - 1057381316740854*x**9 + 5322350909401902*x**8 - 9622764827760582*x**7 - 3065810973129666*x**6 + 66934021885952490*x**5 - 182407199819079474*x**4 + 145617468141523482*x**3 + 657590794489906398*x**2 - 2846477192318860086*x + 5383617033070744686)/(3**24 * 47**2 * 5)
            g2cxc = g2cx // (g2cxa * g2cxb)
            if choice is None or choice == 2:
                u_m = [459, 19419] # [459, 1747] mod 47^2
                cofactor_r = [1, 1]
                cxa = (x**2 - 3*x + 6)/(2*3*5)
                cxb = (x**2 + 3*x + 6)/(2*3*47**2)
            elif choice == 3:
                u_m = [1134, 6399, 8649, 8994, 9009, 10074, 10389, 10824, 13194, 14244, 14424, 17004, 17274, 17649, 20214, 23574, 27084, 27504, 30054, 30954, 32589]
                cofactor_r = [1]*len(u_m)
                cxa = (x**2 - 3*x + 6)/(2*3*5)
                cxb = (x**2 + 3*x + 6)/(2*3)
            polys_cofact_twists = [cxa, cxb, twxb]
            label_factors = ["cxa", "cxb", "twxb"]
            small_cofactors = [1, 1, 1]

    elif k == 54:
        # for G2: sextic twist over Fp9
        px2 = px**2
        px3 = px*px2
        px6 = px3**2
        px9 = px6*px3
        tx2 = tx**2 - 2*px
        tx3 = tx*tx2 - px*tx
        tx6 = tx3**2 - 2*px3
        tx9 = tx3*tx6 - px3*tx3
        yx9 = yx * (tx**2 - px) * (tx6 + px3)

        # now the 6-th twist that matches rx
        E2_order = px9+1-( 3*yx9+tx9)/2
        g2twx = px9+1+( 3*yx9+tx9)/2
        assert (E2_order % rx) == 0
        g2cx = E2_order // rx # irreducible

        m = 1
        u_m = [0]
        cofactor_r = [1]
        polys_cofact_twists = [cx, twx, g2cx, g2twx]
        label_factors = ["cx", "twx", "g2cx", "g2twx"]
        small_cofactors = [1, 1, 1, 1]

    return m, u_m, cofactor_r, twx, g2cx, g2twx, polys_cofact_twists, label_factors, small_cofactors

def congruence_constraints(k, D=None, choice=None):
    if k == 8:
        m = 30
        u_m = [5, 25]
    elif k == 16:
        if D is None or D == 1 or D == 4:
            if choice is None or choice == 0:
                m = 70
                u_m = [25, 45]
            elif choice == 1:
                m = 3094
                u_m = [13, 169, 715, 897, 2197, 2379, 2925, 3081]
            elif choice == 2:
                m = 26350
                u_m = [925, 2475, 8375, 11775, 14575, 17975, 23875, 25425]
            elif choice == 3:
                m = 80782
                u_m = [24843, 55939]
        elif D == 35:
            m = 1360170
            u_m = [3816, 83826, 149346, 229356, 243846, 389376, 469386, 563886, 629406, 643896, 949446, 963936, 1029456, 1123956, 1203966, 1349496]
        elif D == 227:
            m = 9168872997
            u_m = [547293936, 681251403, 843532341, 1277558157, 2872044066, 2981508006, 3602308287, 3711772227, 5306258136, 5740283952, 5902564890, 6036522357, 7525374270, 7687655208, 8065034082, 8227315020]
    elif k == 18:
        if choice is None or choice in [0, 1]:
            m = 21
            u_m = [14] # 14 mod 21 only. With 7 mod 21, px is always multiple of 3.
        elif choice in [2,3,4]:
            m = 357
            u_m = [189]
        elif choice in [5,6]:
            m = 399 # 3*7*19
            u_m = [7, 49, 343]
        elif choice in [7,8]:
            m = 663 # 3*13*17
            u_m = [247]
        else:
            m = 21
            u_m = [14]
    elif k == 20:
        m = 2050 # 2*5**2*41
        if choice is None or choice == 0:
            #u_mod_m = [315, 1365, 1715, 1815, 1965]
            #cofactor_r = [41, 41, 1, 1, 41]
            u_mod_m = [1715, 1815]
            cofactor_r = [1, 1]
        else:
            #u_m = [915, 1315, 1465, 1565, 1915]
            #cofactor_r = [41,41,1,1,41]
            u_m = [1465, 1565] #for the other values, r is not prime and there is a cofactor to adjust with cx and rx
            cofactor_r = [1, 1]
    elif k == 22:
        if D is None or D == 7:
            if choice is None or choice in [0,1]:
                m = 161
                if choice is None or choice == 0:
                    u_m = [32, 151]
                else:
                    u_m = [4,18,25,39,81,95,116,123,144]
            else: # choice in [2,3]
                m = 5159
                if choice == 2:
                    u_m = [2933, 3626]
                else:
                    u_m = [161, 1008, 1316, 1393, 2009, 2856, 3087, 3395, 4011]
        elif D == 3:
            m = 2814
            if choice is None or choice == 0:
                u_m = [2157, 2661]
            else:
                u_m = [57, 519, 855, 1023, 1275, 1317, 1401, 1569, 2241]
        elif D == 1:
            m = 13210
            if choice is None or choice == 0:
                u_m = [513, 10053]
            else:
                u_m = [2013, 4313, 5673, 9533, 9663, 9753, 9983, 10673, 11053]
    elif k == 28 and (D is None or D == 1):
        m = 2030
        if choice is None or choice == 0:
            u_m = [309, 449, 1759, 1899] # so that rx can take prime values
        elif choice == 1:
            u_m = [79, 359, 379, 659, 939, 989, 1409, 1569, 1829, 1989]
        elif choice == 2:
            u_m = [135, 275, 715, 855]
        elif choice == 3:
            u_m = [205, 365, 485, 765, 785, 1065, 1345, 1395, 1815, 1975]
    elif k == 28 and D == 11:
        m = 35607
        u_m = [5076, 9366, 13293, 17583]
    elif k == 32:
        m = 6214
        u_m = [325, 5889] # 325 or 5889 = -325 mod 6214
    elif k == 36:
        m = 777
        u_m = [287, 308, 497, 539, 728, 749] # it means 2 mod 3, 0 mod 7, and one of 9, 12, 16, 21, 25, 28 mod 37
    elif k == 40:
        m = 2370
        u_m = [415, 1165, 1205, 1955] # 1955 = 2370-415, 1205 = 2370-1165
    elif k == 46:
        if D is None or D == 7:
            m = 6769
            if choice is None or choice == 0:
                u_m = [1235, 2202, 3601, 4568]
            else:
                u_m = [116, 837, 864, 1046, 1277, 1795, 1831, 2013, 2244, 2733, 2740, 2762, 3020, 3517, 3700, 3707, 3818, 3987, 4343, 4484, 4497, 4700, 4721, 4785, 4791, 4847, 5155, 5190, 5253, 5310, 5330, 5464, 5667, 5688, 5758, 5814, 5918, 6122, 6157, 6220, 6297, 6639]
        elif D == 15:
            m = 33135
            if choice is None or choice == 2:
                u_m = [459, 19419] # rx can take prime values
                # corresponds to [459, 1747] mod 47^2
            else:
                # 47^2 | r
                u_m = [1134, 6399, 8649, 8994, 9009, 10074, 10389, 10824, 13194, 14244, 14424, 17004, 17274, 17649, 20214, 23574, 27084, 27504, 30054, 30954, 32589]

    elif k == 54:
        m = 1
        u_m = [0]
    return m, u_m

class GG(EllipticCurve_finite_field):
    """
    A Gasnier-Guillevic curve of embedding degree k in (16,18,20,22,28,46)
    An algebraic point of view on the generation of pairing-friendly curves
    Jean Gasnier and Aurore Guillevic
    https://hal.science/hal-04205681
    """
    def __init__(self, k, u, a=None, b=None, cofactor_r=None, D=None, choice_gg=None, verbose_init=False):
        """
        Create a GG curve

        INPUT:
        - `k`: embedding degree
        - `u`: seed such that p=P_GG_k(u) and r = R_GG_k(u)
        - `a`: curve coefficient, if D=1: y^2 = x^3 + a*x has a subgroup of order r
        - `b`: curve coefficient, if D=3: y^2 = x^3 + b has a subgroup of order r
        - `cofactor_r`: a cofactor in r=R_GG_k(u) (if not given and r not prime, raise error)
        - `choice_gg`: for k=16, k=18, k=20, k=22, k=28, there are two possible families, 0 (or choice_gg is None) or 1
        - `D`: for k=16, k=22, there are several choices of D in addition to "choice_gg"
        """
        self._k = k # embedding degree
        self._choice_gg = choice_gg
        self._px, self._px_denom, self._rx, self._rx_denom, self._tx, self._tx_denom, self._cx, self._cx_denom, self._yx, self._yx_denom, self._betax, self._betax_denom, self._lambx, self._lambx_denom, self._D = coeffs_params(k, D, choice_gg)

        self._u = Integer(u)
        self._p = sum([Integer(self._px[i])*self._u**i for i in range(len(self._px))])//self._px_denom
        self._pbits = self._p.nbits()
        self._r = sum([Integer(self._rx[i])*self._u**i for i in range(len(self._rx))])//self._rx_denom
        self._tr= sum([Integer(self._tx[i])*self._u**i for i in range(len(self._tx))])//self._tx_denom
        self._y = sum([Integer(self._yx[i])*self._u**i for i in range(len(self._yx))])//self._yx_denom
        self._c = sum([Integer(self._cx[i])*self._u**i for i in range(len(self._cx))])//self._cx_denom
        if not self._c * self._r == self._p + 1 - self._tr:
            if self._c * self._r == self._p + 1 + self._tr:
                raise ValueError("Error: r*c != p+1-tr but r*c = p+1+tr this is the quadratic twist\nr={}\nc={}\np+1-tr={}\n".format(self._r,self._c,self._p+1-self._tr))
            else:
                raise ValueError("Error: r*c != p+1-tr\nr={}\nc={}\np+1-tr={}\nr*c   ={}\n".format(self._r,self._c,self._p+1-self._tr, self._r*self._c))


        # GLV parameter for fast scalar multiplication thanks to automorphism
        # if D=3:
        # psi: (x,y) -> (beta*x,y) = [lambda mod r]*(x,y) if (x,y) is of order r
        # where beta is a root of x^2+x+1 mod p, beta = (-1 + sqrt(Fp(-3)))/2
        # and lambda is a root of x^2+x+1 mod r, lamb = (-1 + sqrt(Fr(-3)))/2
        # there are two choices: beta, -beta-1, and the same for lamb: lamb, -lamb-1
        # if D=1:
        # psi: (x,y) -> (-x,i*y) = [lambda mod r]*(x,y) if (x,y) is of order r
        # where beta is a root of x^2+1 mod p, beta = sqrt(-1) mod p
        # and lambda is a root of x^2+1 mod r, lamb = sqrt(-1) mod r
        # there are two choices: beta, -beta, and the same for lamb: lamb, -lamb
        # arbitrarily the positive ones are chosen in the polynomials, adjust the choice
        if self._betax != 0 and self._lambx != 0:
            self._beta = sum([Integer(self._betax[i])*self._u**i for i in range(len(self._betax))]) # will divide by self._betax_denom later
            self._lamb = sum([Integer(self._lambx[i])*self._u**i for i in range(len(self._lambx))])
        else:
            self._beta = 0
            self._lamb = 0

        try:
            self._Fp = FiniteField(self._p)
        except ValueError as err:
            print("ValueError creating Fp: {}".format(err))
            print("p= {}".format(self._p))
            raise
        except:
            print("Error creating Fp")
            raise
        if cofactor_r is not None:
            self._cofactor_r = Integer(cofactor_r)
        else:
            self._cofactor_r = Integer(1)
        if self._cofactor_r > 1:
            rem_cofact_r = (self._r % self._cofactor_r)
            if (rem_cofact_r == 0):
                self._r //= self._cofactor_r
                self._c *= self._cofactor_r
            else:
                raise ValueError("Error cofactor of r given is {} but r % cofactor = {}".format(cofactor_r, rem_cofact_r))
        if not self._r.is_prime():
            raise ValueError("Error r is not prime")

        if (self._beta != 0) and (self._betax_denom != 1):
            self._betax_denom = Integer(self._betax_denom)
            if (self._beta % self._betax_denom) == 0:
                self._beta = self._beta // self._betax_denom
            else:
                self._beta = Integer(self._Fp(self._beta)/self._Fp(self._betax_denom))

        if (self._lamb != 0) and (self._lambx_denom != 1):
            self._lamb_denom = Integer(self._lambx_denom)
            if (self._lamb % self._lambx_denom) == 0:
                self._lamb = self._lamb // self._lambx_denom
            else:
                # invert denominator mod r
                Rr = IntegerModRing(self._r)
                self._lamb = Integer(Rr(self._lamb)/Rr(self._lambx_denom))

        if self._D == 3:
            if ((self._beta**2 + self._beta + 1) % self._p) != 0:
                raise ValueError("Error beta^2 + beta + 1 != 0 mod p")
            if ((self._lamb**2 + self._lamb + 1) % self._r) != 0:
                raise ValueError("Error lamb^2 + lamb + 1 != 0 mod r")
        elif self._D == 1 or self._D == 4:
            if ((self._beta**2 + 1) % self._p) != 0:
                raise ValueError("Error beta^2 + 1 != 0 mod p")
            if ((self._lamb**2 + 1) % self._r) != 0:
                raise ValueError("Error lamb^2 + 1 != 0 mod r")
        elif self._beta != 0 and self._lamb != 0 and (self._D % 4) == 3:
            if ((self._beta**2 + self._beta + (self._D+1)//4) % self._p) != 0:
                raise ValueError("Error beta^2 + beta + {0} != 0 mod p where D={1}, (D+1)/4 = {0}".format((self._D+1)//4, self._D))
            if ((self._lamb**2 + self._lamb + (self._D+1)//4) % self._r) != 0:
                raise ValueError("Error lamb^2 + lamb + {0} != 0 mod r where D={1}, (D+1)/4 = {0}".format((self._D+1)//4, self._D))
        elif self._beta != 0 and self._lamb != 0 and (self._D % 4) == 1:
            if ((self._beta**2 + self._D) % self._p) != 0:
                raise ValueError("Error beta^2 + D != 0 mod p where D={}".format(self._D))
            if ((self._lamb**2 + self._D) % self._r) != 0:
                raise ValueError("Error lamb^2 + D != 0 mod r where D={}".format(self._D))

        self._Fpz = PolynomialRing(self._Fp, names=('z',))
        (self._z,) = self._Fpz._first_ngens(1)

        if self._D == 3:
            self._a = 0
            self._ap = self._Fp(0) # first curve parameter is 0 because j=0
            if b == None:
                # check that beta = 2*U/(-3*V-U) before, where U=t/2, V = y/2 and 2V = 2 mod 3
                self._b, self._bp = get_curve_parameter_b_j0(self._tr, self._y, self._p, self._Fp)
            else:
                try:
                    b = Integer(b)
                except:
                    raise
                self._b = b
                self._bp = self._Fp(b)
        elif self._D == 1 or self._D == 4:
            self._b = 0
            self._bp = self._Fp(0) # second curve parameter is 0 because j=1728
            if a == None:
                # check that beta = U/V, where U=t/2, V = y
                self._a, self._ap = get_curve_parameter_a_j1728(self._tr, self._y, self._p, self._Fp)
            else:
                try:
                    a = Integer(a)
                except:
                    raise
                self._a = a
                self._ap = self._Fp(a)
        elif a == None and b == None:
            raise ValueError("Only D=1 or D=3 is implemented for guessing a,b, please provide a,b")
        else:
            try:
                a = Integer(a)
                b = Integer(b)
            except:
                raise
            self._a = a
            self._ap = self._Fp(a)
            self._b = b
            self._bp = self._Fp(b)
        try:
            # this init function of super inherits from class EllipticCurve_generic defined in ell_generic.py
            # __init__ method inherited from ell_generic
            EllipticCurve_finite_field.__init__(self, self._Fp, [0,0,0,self._ap,self._bp])
        except ValueError as err:
            print("ValueError at EllipticCurve_finite_field.__init__: {}".format(err))
            raise
        except:
            print("An error occupred when initialising the elliptic curve")
            raise
        # check the curve order.
        # With D=3 and j=0, there are 6 possible orders
        # p+1-t
        # p+1+t # quadratic twist
        # p+1-(3*y-t)/2  # cubic twist
        # p+1-(-3*y-t)/2 # other cubic twist
        # p+1-(3*y+t)/2  # sextic twist
        # p+1-(-3*y+t)/2 # other sextic twist
        # With D=1 and j=1728, there are 4 possible orders
        # p+1-t
        # p+1+t # quadratic twist
        # p+1-y # quartic twist
        # p+1+y # other quartic twist
        # with the convention D=4, this is p+1-2*y and p+1+2*y

        self.curve_order = self._p + 1 - self._tr
        self.twist_order = self._p + 1 + self._tr
        if self._D == 3:
            cubic_twist1_order = self._p + 1 - (3*self._y-self._tr)//2
            cubic_twist2_order = self._p + 1 - (-3*self._y-self._tr)//2
            sextic_twist1_order = self._p + 1 - (3*self._y+self._tr)//2
            sextic_twist2_order = self._p + 1 - (-3*self._y+self._tr)//2
        elif self._D == 1:
            quartic_twist1_order = self._p + 1 - self._y
            quartic_twist2_order = self._p + 1 + self._y
        elif self._D == 4:
            quartic_twist1_order = self._p + 1 - 2*self._y
            quartic_twist2_order = self._p + 1 + 2*self._y
        for i in range(10):
            P = self.random_element()
            if self.curve_order*P != self(0):
                if self.twist_order*P == self(0):
                    raise ValueError("Wrong curve order: this one is a twist: (p+1+tr)*P = 0\ntr={}\nr={}\np+1+tr={}\n".format(self._tr,self.curve_order,self.twist_order))
                elif self._D == 3:
                    if cubic_twist1_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a cubic twist: (p+1-(3*y-t)/2)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-(3*y-t)/2)={}\n".format(self._tr,self._y,self.curve_order,cubic_twist1_order))
                    elif cubic_twist2_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a cubic twist: (p+1-(-3*y-t)/2)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-(-3*y-t)/2)={}\n".format(self._tr,self._y,self.curve_order,cubic_twist2_order))
                    elif sextic_twist1_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a sextic twist: (p+1-(3*y+t)/2)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-(3*y+t)/2)={}\n".format(self._tr,self._y,self.curve_order,sextic_twist1_order))
                    elif sextic_twist2_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a sextic twist: (p+1-(-3*y+t)/2)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-(-3*y+t)/2)={}\n".format(self._tr,self._y,self.curve_order,sextic_twist2_order))
                elif self._D == 1:
                    if quartic_twist1_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a quartic twist: (p+1-y)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-y)={}\n".format(self._tr,self._y,self.curve_order,quartic_twist1_order))
                    elif quartic_twist2_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a quartic twist: (p+1+y)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1+y)={}\n".format(self._tr,self._y,self.curve_order,quartic_twist2_order))
                elif self._D == 4:
                    if quartic_twist1_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a quartic twist: (p+1-2*y)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1-2*y)={}\n".format(self._tr,self._y,self.curve_order,quartic_twist1_order))
                    elif quartic_twist2_order*P == self(0):
                        raise ValueError("Wrong curve order: this one is a quartic twist: (p+1+2*y)*P = 0\ntr={}\ny={}\np+1-t={}\n(p+1+2*y)={}\n".format(self._tr,self._y,self.curve_order,quartic_twist2_order))

        # computes a generator
        if self._D == 3:
            self._G = get_curve_generator_order_r_j0(self)
        elif self._D == 1 or self._D == 4:
            self._G = get_curve_generator_order_r_j1728(self)
        if self._D in [1,3,4]:
            self._Gx = self._G[0]
            self._Gy = self._G[1]

        # adjust beta and lamb according to the curve
        if self._D == 3:
            # do we have (beta*x,y) = lamb*(x,y)?
            if self([self._Gx*self._beta, self._Gy]) != self._lamb*self._G:
                if verbose_init:
                    print("adjusting beta, lambda")
                if self([self._Gx*(-self._beta-1), self._Gy]) == self._lamb*self._G:
                    self._beta = -self._beta-1
                    if verbose_init:
                        print("beta -> -beta-1")
                elif self([self._Gx*self._beta, self._Gy]) == (-self._lamb-1)*self._G:
                    self._lamb = -self._lamb-1
                    if verbose_init:
                        print("lamb -> -lamb-1")
                elif self([self._Gx*(-self._beta-1), self._Gy]) == (-self._lamb-1)*self._G:
                    self._beta = -self._beta-1
                    self._lamb = -self._lamb-1
                    if verbose_init:
                        print("lamb -> -lamb-1")
                        print("beta -> -beta-1")
                else:
                    raise ValueError("Error while adjusting beta, lamb: compatibility not found")
        elif self._D == 1 or self._D == 4:
            # do we have (-x,beta*y) = lamb*(x,y)?
            if self([-self._Gx, self._Gy*self._beta]) != self._lamb*self._G:
                print("adjusting beta, lambda")
                if self([-self._Gx, self._Gy*(-self._beta)]) == self._lamb*self._G:
                    self._beta = self._p-self._beta
                    print("beta -> -beta")
                elif self([-self._Gx, self._Gy*self._beta]) == (-self._lamb)*self._G:
                    self._lamb = -self._lamb
                    print("lamb -> -lamb")
                elif self([-self._Gx, self._Gy*(-self._beta)]) == (-self._lamb)*self._G:
                    self._beta = self._p-self._beta
                    self._lamb = -self._lamb
                    print("lamb -> -lamb")
                    print("beta -> -beta")
                else:
                    raise ValueError("Error while adjusting beta, lamb: compatibility not found")


    def _repr_(self):
        return "GG{}-{} curve (Gasnier-Guillevic k={}) with seed {} ({:#x})\n".format(self._k, self._pbits, self._k, self._u, self._u)+super(GG,self)._repr_()

    def u(self):
        return self._u
    def T(self):
        return self._u
    def p(self):
        return self._p
    def r(self):
        return self._r
    def c(self):
        return self._c
    def tr(self):
        return self._tr
    def y(self):
        return self._y
    def D(self):
        return self._D
    def a(self):
        return self._a
    def ap(self):
        return self._ap
    def b(self):
        return self._b
    def bp(self):
        return self._bp
    def beta(self):
        return self._beta
    def lamb(self):
        return self._lamb

    def k(self):
        return self._k
    def Fp(self):
        return self._Fp
    def Fpz(self):
        return self._Fpz, self._z
    def G(self):
        return self._G

    def poly_p(self):
        return self._px
    def poly_p_denom(self):
        return self._px_denom
    def poly_r(self):
        return self._rx
    def poly_r_denom(self):
        return self._rx_denom

    def miller_loop_length():
        return self._u

    def print_parameters(self):
        tnfs.curve.pairing_friendly_curve.print_parameters(self)

    def print_parameters_for_RELIC(self):
        tnfs.curve.pairing_friendly_curve.print_parameters_for_RELIC(self)
